<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>数据结构第6章：图 | 诺亚方舟</title><meta name="author" content="弘树"><meta name="copyright" content="弘树"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="1 图的存储图的存储结构至少要保存两类信息：	  顶点的数据 顶点间的关系  如何表示顶点间的关系？ 1.1 邻接矩阵图的邻接矩阵(Adjacency Matrix) 存储方式是用两个数组来表示图。一个一维数组存储图中顶点信息，一个二维数组(称为邻接矩阵)存储图中的边或弧的信息。 设图 G 有 n 个顶点，则邻接矩阵 A 是一个$n ∗ n$的方阵，定义为:  下图是一个无向图和它的邻接矩阵：">
<meta property="og:type" content="article">
<meta property="og:title" content="数据结构第6章：图">
<meta property="og:url" content="http://zhouzimu.top/2024/06/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC6%E7%AB%A0%EF%BC%9A%E5%9B%BE/index.html">
<meta property="og:site_name" content="诺亚方舟">
<meta property="og:description" content="1 图的存储图的存储结构至少要保存两类信息：	  顶点的数据 顶点间的关系  如何表示顶点间的关系？ 1.1 邻接矩阵图的邻接矩阵(Adjacency Matrix) 存储方式是用两个数组来表示图。一个一维数组存储图中顶点信息，一个二维数组(称为邻接矩阵)存储图中的边或弧的信息。 设图 G 有 n 个顶点，则邻接矩阵 A 是一个$n ∗ n$的方阵，定义为:  下图是一个无向图和它的邻接矩阵：">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://www.dotcpp.com/oj/ueditor/php/upload/image/20221014/1665738230388021.jpg">
<meta property="article:published_time" content="2024-06-09T14:05:15.000Z">
<meta property="article:modified_time" content="2024-08-06T05:45:49.000Z">
<meta property="article:author" content="弘树">
<meta property="article:tag" content="数据结构">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://www.dotcpp.com/oj/ueditor/php/upload/image/20221014/1665738230388021.jpg"><link rel="shortcut icon" href="/img/favicon.jpg"><link rel="canonical" href="http://zhouzimu.top/2024/06/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC6%E7%AB%A0%EF%BC%9A%E5%9B%BE/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css?v=4.12.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.5.1/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.32/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":true,"top_n_per_article":1,"unescape":true,"languages":{"hits_empty":"找不到您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":50,"languages":{"author":"作者: 弘树","link":"链接: ","source":"来源: 诺亚方舟","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.11.0/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '数据结构第6章：图',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-08-06 13:45:49'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
        if (t === 'dark') activateDarkMode()
        else if (t === 'light') activateLightMode()
      
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><link rel="stylesheet" href="/css/myStyle.css"><link rel="stylesheet" href="/css/tianli_gpt.css"><meta name="generator" content="Hexo 6.3.0"><link href="https://cdn.bootcss.com/KaTeX/0.11.1/katex.min.css" rel="stylesheet" /></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/pic_editor_1635545191.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">123</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">45</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">17</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 其他</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><i class="fa-fw fas fa-asterisk"></i><span> 归档</span></a></li><li><a class="site-page child" href="/update/"><i class="fa-fw fas fa-archive"></i><span> 更新日志</span></a></li></ul></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg fixed" id="page-header" style="background-image: url('https://www.dotcpp.com/oj/ueditor/php/upload/image/20221014/1665738230388021.jpg')"><nav id="nav"><span id="blog-info"><a href="/" title="诺亚方舟"><span class="site-name">诺亚方舟</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 其他</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><i class="fa-fw fas fa-asterisk"></i><span> 归档</span></a></li><li><a class="site-page child" href="/update/"><i class="fa-fw fas fa-archive"></i><span> 更新日志</span></a></li></ul></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">数据结构第6章：图</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="fa-fw post-meta-icon far fa-calendar-alt"></i><span class="post-meta-label">发表于</span><time datetime="2024-06-09T14:05:15.000Z" title="发表于 2024-06-09 22:05:15">2024-06-09</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E4%B8%93%E4%B8%9A%E8%AF%BE/">专业课</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">6.5k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>26分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="数据结构第6章：图"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><meta name="referrer" content="no-referrer" />

<h1 id="1-图的存储"><a href="#1-图的存储" class="headerlink" title="1 图的存储"></a>1 图的存储</h1><p>图的存储结构至少要保存两类信息：	</p>
<ol>
<li>顶点的数据</li>
<li>顶点间的关系</li>
</ol>
<p>如何表示顶点间的关系？</p>
<h2 id="1-1-邻接矩阵"><a href="#1-1-邻接矩阵" class="headerlink" title="1.1 邻接矩阵"></a>1.1 邻接矩阵</h2><p>图的邻接矩阵(Adjacency Matrix) 存储方式是用两个数组来表示图。一个一维数组存储图中顶点信息，一个二维数组(称为邻接矩阵)存储图中的边或弧的信息。</p>
<p>设图 G 有 n 个顶点，则邻接矩阵 A 是一个$n ∗ n$的方阵，定义为:</p>
<p><img src="https://img-blog.csdnimg.cn/20210301095908432.png#pic_center"></p>
<p>下图是一个无向图和它的邻接矩阵：</p>
<p><img src="https://img-blog.csdnimg.cn/202103011006555.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1JlYWxfRm9vbF8=,size_16,color_FFFFFF,t_70#pic_center"></p>
<p>可以看出：</p>
<ol>
<li>无向图的邻接矩阵一定是一个对称矩阵(即从矩阵的左上角到右下角的主对角线为轴，右上角的元与左下角相对应的元全都是相等的)。 因此，在实际存储邻接矩阵时只需存储上(或下)三角矩阵的元素。</li>
<li>对于无向图，邻接矩阵的第i行(或第i列)非零元素(或非∞元素)的个数正好是第i个顶点的度。</li>
<li>有向图中：<ul>
<li>顶点 $ V_{i} $ 的出度是A中第 i 行元素之和</li>
<li>顶点 $ V_{i} $ 的入度是A中第 i 列元素之和</li>
</ul>
</li>
</ol>
<p><strong>邻接矩阵存储适用于稠密图。</strong></p>
<h2 id="1-2-邻接表"><a href="#1-2-邻接表" class="headerlink" title="1.2 邻接表"></a>1.2 邻接表</h2><p>当一个图为稀疏图时（边数相对顶点较少），使用邻接矩阵法显然要浪费大量的存储空间，如下图所示：</p>
<p><img src="https://img-blog.csdnimg.cn/20210301113238489.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1JlYWxfRm9vbF8=,size_16,color_FFFFFF,t_70#pic_center"></p>
<p>而图的邻接表法结合了顺序存储和链式存储方法，大大减少了这种不必要的浪费。</p>
<p>邻接表类似于树的孩子表示法，如果能把图中任一个顶点的所有邻接点都表示出来，也就可以表示图。</p>
<p>实现：为图中每个顶点建立一个单链表，第i个单链表中的结点表示依附于顶点Vi的边（有向图中指以Vi为尾的弧）。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 图的邻接表存储</span></span><br><span class="line"><span class="type">int</span> h[N], e[N], ne[N], idx;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	e[idx] = b, ne[idx] = h[a], h[a] = idx ++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>无向图的邻接表的实例如下图所示：</p>
<p><img src="https://img-blog.csdnimg.cn/20210301165232511.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1JlYWxfRm9vbF8=,size_16,color_FFFFFF,t_70#pic_center"></p>
<h3 id="1-2-1-邻接表表示的特点"><a href="#1-2-1-邻接表表示的特点" class="headerlink" title="1.2.1 邻接表表示的特点"></a>1.2.1 邻接表表示的特点</h3><ol>
<li>无向图中顶点Vi的度为第i个单链表中的结点数</li>
<li>有向图中<ul>
<li>顶点Vi的出度为第i个单链表中的结点个数</li>
<li>顶点Vi的入度为整个单链表中邻接点域值是i的结点个数</li>
</ul>
</li>
<li>逆邻接表：有向图中对每个结点建立以Vi为头的弧的单链表</li>
</ol>
<h2 id="1-3-十字链表"><a href="#1-3-十字链表" class="headerlink" title="1.3 十字链表"></a>1.3 十字链表</h2><p>十字链表是<strong>有向图</strong>的一种链式存储结构。</p>
<p>对于有向图来说，邻接表是有缺陷的。关心了出度问题，想了解入度就必须要遍历整个图才能知道，反之，逆邻接表解决了入度却不了解出度的情况。有没有可能把邻接表与逆邻接表结合起来呢?答案是肯定的，就是把它们整合在一起。这就是我们现在要介绍的有向图的一种存储方法：十字链表(Orthogonal List)。</p>
<p>重新定义顶点表结点结构如下表所示。</p>
<p><img src="https://img-blog.csdnimg.cn/20210301175445875.png#pic_center"></p>
<p>其中 $ firstin $ 表示入边表头指针，指向该顶点的入边表中第一个结点，$ firstout $ 表示出边表头指针，指向该顶点的出边表中的第一个结点。</p>
<p>重新定义的边表结点结构如下表所示。</p>
<p><img src="https://img-blog.csdnimg.cn/20210301175546226.png#pic_center"></p>
<p>其中$tailvex$是指弧起点在顶点表的下标，$headvex$ 是指弧终点在顶点表中的下标， $ headlink $ 是指入边表指针域，指向终点相同的下一条边，$ taillink $ 是指边表指针域，指向起点相同的下一条边。如果是网，还可以再增加一个 $ weight $ 域来存储权值。</p>
<p><strong>举例如下：</strong></p>
<p><img src="https://img-blog.csdnimg.cn/20210301180237656.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1JlYWxfRm9vbF8=,size_16,color_FFFFFF,t_70#pic_center"></p>
<p>十字链表的好处就是因为把邻接表和逆邻接表整合在了一起，这样既容易找到以$ V_{i} $为尾的弧，也容易找到以$ V_{i} $为头的弧，因而容易求得顶点的出度和入度。</p>
<p>而且它除了结构复杂一点外，其实创建图算法的时间复杂度是和邻接表相同的，因此，在有向图的应用中，十字链表是非常好的数据结构模型。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxNum = <span class="number">100</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">arcNode</span> &#123;    <span class="comment">//弧结点类型</span></span><br><span class="line">	<span class="type">int</span> tail;				<span class="comment">//弧尾下标</span></span><br><span class="line">	<span class="type">int</span> head;				<span class="comment">//弧头下标</span></span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">arcNode</span>*hlink;	<span class="comment">//指针，指向同弧头的弧</span></span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">arcNode</span>*tlink;	<span class="comment">//指针，指向同弧尾的弧</span></span><br><span class="line">&#125;arcNode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">vexNode</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">char</span> data;				<span class="comment">//指点数据</span></span><br><span class="line">	arcNode *firstIn;		<span class="comment">//指针，指向第一个入弧</span></span><br><span class="line">	arcNode *firstout;		<span class="comment">//指针，指向第一个出弧</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line">	vexNode vex[maxNum];</span><br><span class="line">	<span class="type">int</span> vexnum, edgenum;	<span class="comment">//顶点数量，边数量</span></span><br><span class="line">&#125;OLGraph;</span><br><span class="line"></span><br><span class="line">OLGraph g;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">LocateVex</span><span class="params">(<span class="type">char</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; g.vexnum; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (g.vex[i].data == c)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">return</span> i;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insertedge</span><span class="params">(<span class="type">char</span> a, <span class="type">char</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> ai = <span class="built_in">LocateVex</span>(a);</span><br><span class="line">	<span class="type">int</span> bi = <span class="built_in">LocateVex</span>(b);</span><br><span class="line">	arcNode* an = <span class="keyword">new</span> arcNode;  <span class="comment">// 生成一条新弧</span></span><br><span class="line">	an-&gt;tlink = g.vex[ai].firstout;		</span><br><span class="line">	an-&gt;head = bi;						<span class="comment">//由ai-&gt;bi</span></span><br><span class="line">	an-&gt;tail = ai;</span><br><span class="line">	g.vex[ai].firstout = an;			<span class="comment">//顶点第一个出弧更新，头插入</span></span><br><span class="line">	an-&gt;hlink = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">if</span> (g.vex[bi].firstIn == <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		g.vex[bi].firstIn = an;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> </span><br><span class="line">	&#123;</span><br><span class="line">		arcNode* curArc = g.vex[bi].firstIn;		<span class="comment">//找到最后一个入弧,尾插入</span></span><br><span class="line">		<span class="keyword">while</span> (curArc-&gt;hlink != <span class="literal">NULL</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			curArc = curArc-&gt;hlink;</span><br><span class="line">		&#125;</span><br><span class="line">		curArc-&gt;hlink = an;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CreateOLGraph</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;请输入顶点数量和边数：&quot;</span> &lt;&lt; endl;</span><br><span class="line">	cin &gt;&gt; g.vexnum &gt;&gt; g.edgenum;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;输入对应的顶点:&quot;</span> &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; g.vexnum; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		cin &gt;&gt; g.vex[i].data;</span><br><span class="line">		g.vex[i].firstIn = <span class="literal">NULL</span>; </span><br><span class="line">		g.vex[i].firstout = <span class="literal">NULL</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;输入要插入的边&quot;</span> &lt;&lt; endl;</span><br><span class="line">	<span class="type">int</span> m = g.edgenum;</span><br><span class="line">	<span class="keyword">while</span> (m &gt; <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">char</span> a, b;</span><br><span class="line">		cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">		<span class="built_in">insertedge</span>(a, b);</span><br><span class="line">		m--;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">GetOLVexDu</span><span class="params">()</span> </span>&#123;			<span class="comment">//获得十字链表中某一个点的入度和出度</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; g.vexnum; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		vexNode n = g.vex[i];</span><br><span class="line">		cout &lt;&lt; n.data &lt;&lt; <span class="string">&quot;的出度有&quot;</span> &lt;&lt; <span class="string">&quot; : &quot;</span>;</span><br><span class="line">		arcNode* outArc = n.firstout;</span><br><span class="line">		<span class="keyword">while</span> (outArc != <span class="literal">NULL</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			cout &lt;&lt; outArc-&gt;head &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">			outArc = outArc-&gt;tlink;</span><br><span class="line">		&#125;</span><br><span class="line">		cout &lt;&lt; endl;</span><br><span class="line">		cout &lt;&lt; n.data &lt;&lt; <span class="string">&quot;的入度有&quot;</span> &lt;&lt; <span class="string">&quot; : &quot;</span>;</span><br><span class="line">		arcNode* inArc = n.firstIn;</span><br><span class="line">		<span class="keyword">while</span> (inArc != <span class="literal">NULL</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			cout &lt;&lt; inArc-&gt;tail &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">			inArc = inArc-&gt;hlink;</span><br><span class="line">		&#125;</span><br><span class="line">		cout &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">CreateOLGraph</span>();</span><br><span class="line">	<span class="built_in">GetOLVexDu</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="1-4-邻接多重表"><a href="#1-4-邻接多重表" class="headerlink" title="1.4 邻接多重表"></a>1.4 邻接多重表</h2><p>邻接多重表是<strong>无向图</strong>的另一种链式存储结构。</p>
<p>在邻接表中，容易求得顶点和边的各种信息，但在邻接表中求两个顶点之间是否存在边而对边执行删除等操作时，需要分别在两个顶点的边表中遍历，效率较低。</p>
<p>比如下图中，若要删除左图的（$v_0$, $v_2$）这条边，需要对邻接表结构中右边表的阴影两个结点进行删除操作，显然这是比较烦琐的。</p>
<p><img src="https://img-blog.csdnimg.cn/20210301182203109.png#pic_center"></p>
<p>重新定义的边表结点结构如下表所示。</p>
<p><img src="https://img-blog.csdnimg.cn/20210301183315496.png#pic_center"></p>
<p>其中 $ivex$ 和 $jvex$ 是与某条边依附的两个顶点在顶点表中下标。$ilink$ 指向依附顶点 $ivex$ 的下一条边，$jlink$ 指向依附顶点 $jvex$ 的下一条边。这就是邻接多重表结构。</p>
<p>每个顶点也用一一个结点表示，它由如下所示的两个域组成。</p>
<p><img src="https://img-blog.csdnimg.cn/20210301183423578.png#pic_center"></p>
<p>其中，$data$ 域存储该顶点的相关信息，$firstedge$ 域指示第一条依附于该顶点的边。</p>
<p><strong>举例如下：</strong></p>
<p><img src="https://img-blog.csdnimg.cn/20210301185220315.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1JlYWxfRm9vbF8=,size_16,color_FFFFFF,t_70#pic_center"></p>
<hr>
<h1 id="2-图的遍历"><a href="#2-图的遍历" class="headerlink" title="2 图的遍历"></a>2 图的遍历</h1><p>图的遍历（Traversing Graph）：从图中某一个顶点出发，访问图中的其余顶点，且使每个顶点仅被访问一次。</p>
<p>主要有深度优先搜索和广度优先搜索，它们对无向图和有向图都适用。</p>
<ul>
<li>深度优先搜索类似于树的先根遍历</li>
<li>广度优先搜索类似于树的层次遍历</li>
</ul>
<h2 id="2-1-DFS"><a href="#2-1-DFS" class="headerlink" title="2.1 DFS"></a>2.1 DFS</h2><p>从图的某一顶点$V_{0}$出发，访问此顶点；然后依次从$V_{0}$的未被访问的邻接点出发，深度优先遍历图，直至图中所有和$V_{0}$相通的顶点都被访问到；</p>
<p>若此时图中尚有顶点未被访问，则另选图中一个未被访问的顶点作起点，重复上述过程，直至图中所有顶点都被访问为止。</p>
<h3 id="2-1-1-DFS代码模板"><a href="#2-1-1-DFS代码模板" class="headerlink" title="2.1.1 DFS代码模板"></a>2.1.1 DFS代码模板</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> st[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    st[u] = <span class="literal">true</span>;  <span class="comment">// st[u] 表示点u已经被遍历过</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = h[u]; i != <span class="number">-1</span>; i = ne[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> j = e[i];</span><br><span class="line">        <span class="keyword">if</span> (!st[j]) <span class="built_in">dfs</span>(j);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://img-blog.csdnimg.cn/20210302110631863.png#pic_center"></p>
<ul>
<li>对于同一个图，基于邻接矩阵的遍历得到的DFS序列和BFS序列是唯一的</li>
<li>基于邻接表遍历所得到的DFS序列和BFS序列是不唯一的</li>
</ul>
<h3 id="2-1-2-性能分析"><a href="#2-1-2-性能分析" class="headerlink" title="2.1.2 性能分析"></a>2.1.2 性能分析</h3><ul>
<li><strong>空间复杂度</strong>：递归算法，需要使用递归栈，空间复杂度为$O(V)$，$V$为顶点数</li>
<li><strong>时间复杂度</strong>：遍历过程实际上是查找每个点的临界点的过程<ul>
<li>邻接矩阵：查找每个顶点的邻接点需要时间为$O(|V|)$，总时间复杂度为$O(|V^2|)$</li>
<li>邻接表：查找每个顶点的邻接点需要时间为$O(|E|)$，总时间复杂度为$O(|V|+|E|)$</li>
</ul>
</li>
</ul>
<h2 id="2-2-BFS"><a href="#2-2-BFS" class="headerlink" title="2.2 BFS"></a>2.2 BFS</h2><p>从图的某一顶点$V_{0}$出发，访问此顶点后，依次访问$V_{0}$的各个未曾访问过的邻接点；然后分别从这些邻接点出发，广度优先遍历图，直至图中所有已被访问的顶点的邻接点都被访问到；</p>
<p>若此时图中尚有顶点未被访问，则另选图中一个未被访问的顶点作起点，重复上述过程，直至图中所有顶点都被访问为止。</p>
<h3 id="2-2-1-BFS代码模板"><a href="#2-2-1-BFS代码模板" class="headerlink" title="2.2.1 BFS代码模板"></a>2.2.1 BFS代码模板</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">bfs</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">	st[<span class="number">1</span>] = <span class="literal">true</span>;  <span class="comment">// 表示1号点已经被遍历过</span></span><br><span class="line">	q.<span class="built_in">push</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (q.<span class="built_in">size</span>())</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> t = q.<span class="built_in">front</span>();</span><br><span class="line">		q.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = h[t]; i != <span class="number">-1</span>; i = ne[i])</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="type">int</span> j = e[i];</span><br><span class="line">			<span class="keyword">if</span> (!st[j])</span><br><span class="line">			&#123;</span><br><span class="line">				st[j] = <span class="literal">true</span>;  <span class="comment">// 表示点j已经被遍历过</span></span><br><span class="line">				q.<span class="built_in">push</span>(j);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://hackr.io/blog/media/architecture-of-bfs.png"></p>
<h3 id="2-2-2-性能分析"><a href="#2-2-2-性能分析" class="headerlink" title="2.2.2 性能分析"></a>2.2.2 性能分析</h3><ul>
<li><strong>空间复杂度</strong>：无论使用什么存储方式，BFS都需要借助一个辅助队列$Q$，因此最坏情况下，空间复杂度为$O(|V|)$</li>
<li><strong>时间复杂度</strong>：分析同DFS<ul>
<li>邻接矩阵：$O(|V|^2)$</li>
<li>邻接表：$O(|V|+|E|)$</li>
</ul>
</li>
</ul>
<hr>
<h1 id="3-最小生成树"><a href="#3-最小生成树" class="headerlink" title="3 最小生成树"></a>3 最小生成树</h1><p><strong>生成树</strong>：所有顶点均由边连接在一起，但不存在回路的图。</p>
<p>一个图可以有许多棵不同的生成树，所有生成树具有以下共同特点：</p>
<ol>
<li>生成树的顶点个数与图的顶点个数相同</li>
<li>生成树是图的极小连通子图</li>
<li>一个有n个顶点的连通图的生成树有n-1条边</li>
<li>生成树中任意两个顶点间的路径是唯一的</li>
<li>在生成树中再加一条边必然形成回路</li>
</ol>
<p>含n个顶点n-1条边的图不一定是生成树。</p>
<h2 id="3-1-普利姆（Prim）算法"><a href="#3-1-普利姆（Prim）算法" class="headerlink" title="3.1 普利姆（Prim）算法"></a>3.1 普利姆（Prim）算法</h2><h3 id="3-1-1-算法思想"><a href="#3-1-1-算法思想" class="headerlink" title="3.1.1 算法思想"></a>3.1.1 算法思想</h3><ul>
<li>初始令$U&#x3D;{u_{0}}，(u_{0}∈V), TE&#x3D;\phi$；</li>
<li>在所有$u∈U，v∈V-U$的边$(u,v)∈E$中，找一条代价最小的边($u_{0}$，$v_{0}$)；</li>
<li>将($u_{0}$，$v_{0}$)并入集合TE，同时$v_{0}$并入U；</li>
<li>重复上述操作直至$U&#x3D;V$为止，则$T&#x3D;(V,{TE})$为N的最小生成树；</li>
</ul>
<h3 id="3-1-2-算法过程"><a href="#3-1-2-算法过程" class="headerlink" title="3.1.2 算法过程"></a>3.1.2 算法过程</h3><p><img src="https://img-blog.csdnimg.cn/3e8389add71f4f4f8ff01d977bda755d.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0Njg1NTg0,size_16,color_FFFFFF,t_70"></p>
<h3 id="3-1-3-代码实现"><a href="#3-1-3-代码实现" class="headerlink" title="3.1.3 代码实现"></a>3.1.3 代码实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">510</span>;</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> dist[N];</span><br><span class="line"><span class="type">int</span> g[N][N];</span><br><span class="line"><span class="type">bool</span> st[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">prim</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">memset</span>(dist, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> dist);</span><br><span class="line">	dist[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">	<span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> t = <span class="number">-1</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j ++)</span><br><span class="line">			<span class="keyword">if</span> (!st[j] &amp;&amp; (t == <span class="number">-1</span> || dist[t] &gt; dist[j]))</span><br><span class="line">				t = j;</span><br><span class="line">		st[t] = <span class="literal">true</span>;</span><br><span class="line">		res += dist[t];</span><br><span class="line">		<span class="comment">// 这个一定要加，防止溢出</span></span><br><span class="line">		<span class="keyword">if</span> (res &gt; <span class="number">0x3f3f3f3f</span> / <span class="number">2</span>) <span class="keyword">return</span> <span class="number">0x3f3f3f3f</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j ++)</span><br><span class="line">			dist[j] = <span class="built_in">min</span>(dist[j], g[t][j]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">memset</span>(g, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> g);</span><br><span class="line">	cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">	<span class="keyword">while</span> (m --)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> a, b, c; cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;</span><br><span class="line">		g[a][b] = g[b][a] = <span class="built_in">min</span>(g[a][b], c);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> ans = <span class="built_in">prim</span>();</span><br><span class="line">	<span class="keyword">if</span> (ans &gt; <span class="number">0x3f3f3f3f</span> / <span class="number">2</span>) cout &lt;&lt; <span class="string">&quot;impossible&quot;</span>;</span><br><span class="line">	<span class="keyword">else</span> cout &lt;&lt; ans;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-1-4-性能分析"><a href="#3-1-4-性能分析" class="headerlink" title="3.1.4 性能分析"></a>3.1.4 性能分析</h3><ul>
<li><strong>空间复杂度</strong>：使用一个dist数组用于记录距离，$O(|V|)$</li>
<li><strong>时间复杂度</strong>：两重循环，$O(|V|^2)$，不依赖于E，<strong>适合求解边稠密图的最小生成树</strong></li>
</ul>
<h2 id="3-2-克鲁斯卡尔（Kruskal）算法"><a href="#3-2-克鲁斯卡尔（Kruskal）算法" class="headerlink" title="3.2 克鲁斯卡尔（Kruskal）算法"></a>3.2 克鲁斯卡尔（Kruskal）算法</h2><h3 id="3-2-1-算法思想"><a href="#3-2-1-算法思想" class="headerlink" title="3.2.1 算法思想"></a>3.2.1 算法思想</h3><p>按边权选择合适的边来构造最小生成树。</p>
<ul>
<li>初始状态为只有$n$个顶点而无边的非连通图$T&#x3D;(V,{\phi})$，每个顶点自成一个连通分量；</li>
<li>在$E$中选取代价最小的边，若该边依附的顶点落在$T$中不同的连通分量上，则将此边加入到$T$中；否则，舍去此边，选取下一条代价最小的边依此类推，直至$T$中所有顶点都在同一连通分量上为止；</li>
</ul>
<h3 id="3-2-2-算法过程"><a href="#3-2-2-算法过程" class="headerlink" title="3.2.2 算法过程"></a>3.2.2 算法过程</h3><p><img src="https://img-blog.csdnimg.cn/2020052116522528.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ2NDIzMTY2,size_16,color_FFFFFF,t_70"></p>
<h3 id="3-2-3-代码实现"><a href="#3-2-3-代码实现" class="headerlink" title="3.2.3 代码实现"></a>3.2.3 代码实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">200010</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> a, b, w;</span><br><span class="line">&#125;edges[N];</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> pre[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(Edge&amp; x, Edge&amp; y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> x.w &lt; y.w;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> pre[x] = (pre[x] == x ? x : <span class="built_in">find</span>(pre[x]));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Kruskal</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> res = <span class="number">0</span>, cnt = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i ++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">auto</span> e = edges[i];</span><br><span class="line">		<span class="type">int</span> a = <span class="built_in">find</span>(e.a), b = <span class="built_in">find</span>(e.b);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (a == b) <span class="keyword">continue</span>;</span><br><span class="line">		pre[a] = b;</span><br><span class="line">		res += e.w, cnt ++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> cnt &lt; n - <span class="number">1</span> ? <span class="number">0x3f3f3f3f</span> : res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">	<span class="comment">// 初始化并查集</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++) pre[i] = i;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i ++) </span><br><span class="line">		cin &gt;&gt; edges[i].a &gt;&gt; edges[i].b &gt;&gt; edges[i].w;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">sort</span>(edges + <span class="number">1</span>, edges + <span class="number">1</span> + m, cmp);</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> ans = <span class="built_in">Kruskal</span>();</span><br><span class="line">	<span class="keyword">if</span> (ans == <span class="number">0x3f3f3f3f</span>) cout &lt;&lt; <span class="string">&quot;impossible&quot;</span>;</span><br><span class="line">	<span class="keyword">else</span> cout &lt;&lt; ans;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-2-4-性能分析"><a href="#3-2-4-性能分析" class="headerlink" title="3.2.4 性能分析"></a>3.2.4 性能分析</h3><ul>
<li><strong>空间复杂度</strong>：使用一个$dist$数组用于记录距离，$O(|V|)$</li>
<li><strong>时间复杂度</strong>：通常采用堆来存放边的集合，选择边权最小的边需要$O(log|E|)$的时间，同时遍历每条边，时间复杂度为$O(|E|log|E|)$，<strong>适用于求解边稀疏而顶点较多的图</strong></li>
</ul>
<h3 id="3-2-5-具体应用"><a href="#3-2-5-具体应用" class="headerlink" title="3.2.5 具体应用"></a>3.2.5 具体应用</h3><ul>
<li>n个城市间建立通信联络网</li>
</ul>
<hr>
<h1 id="4-最短路径"><a href="#4-最短路径" class="headerlink" title="4 最短路径"></a>4 最短路径</h1><p>带权有向图G的最短路径问题一般可分为两类：</p>
<ol>
<li>单源最短路</li>
<li>每对顶点间的最短路径</li>
</ol>
<h2 id="4-1-Dijkstra算法"><a href="#4-1-Dijkstra算法" class="headerlink" title="4.1 Dijkstra算法"></a>4.1 Dijkstra算法</h2><p>解决单源最短路径问题的一个常用算法是Dijkstra算法，它是由E.W.Dijkstra提出的一种按路径长度递增的次序产生到各顶点最短路径的贪心算法。</p>
<h3 id="4-1-1-算法思想"><a href="#4-1-1-算法思想" class="headerlink" title="4.1.1 算法思想"></a>4.1.1 算法思想</h3><p>首先，在这些最短路径中，长度最短的这条路径上必定只有一条弧，且它的权值是从源点出发的所有弧上权的最小值。</p>
<p>其次，第二条长度次短的最短路径只可能有两种情况：</p>
<ol>
<li><p>或者只含一条从源点出发的弧且小于其它从源点出发的弧上的权值；&#x20;</p>
</li>
<li><p>或者是一条只经过已求得最短路径的顶点的路径。</p>
</li>
</ol>
<p>依次类推，按迪杰斯特拉算法先后求得的每一条最短路径必定只有两种情况，或者是由源点直接到达终点，或者是只经过已经求得最短路径的顶点到达终点。</p>
<h3 id="4-1-2-求最短路径步骤-xD"><a href="#4-1-2-求最短路径步骤-xD" class="headerlink" title="4.1.2 求最短路径步骤&#xD;"></a>4.1.2 求最短路径步骤&#xD;</h3><ol>
<li>初始化：令 S&#x3D;{V0}，T&#x3D;{其余顶点}，dist[]的初始值$dist[i]&#x3D;arcs[0][i], i&#x3D;1,2,…,n-1$。</li>
<li>从顶点集合V-S中选出$v_{j}$，满足$dist[j]&#x3D; \min {dist[i]|vi\in V-S}$，$v_{j}$就是当前求得的一条从$v_{0}$出发的最短路径的终点，令$S&#x3D;S\bigcup{j}$。</li>
<li>对T中顶点的距离值进行修改：若加进W作中间顶点，从V0到Vi的距离值比不加W的路径要短，则修改此距离值。</li>
<li>重复上述步骤，直到S中包含所有顶点，即S&#x3D;V为止。</li>
</ol>
<p><img src="/2024/06/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC6%E7%AB%A0%EF%BC%9A%E5%9B%BE/image_SD_1cEKC7Q.png"></p>
<h3 id="4-1-3-代码实现"><a href="#4-1-3-代码实现" class="headerlink" title="4.1.3 代码实现"></a>4.1.3 代码实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 稠密图，采用邻接矩阵存储</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">510</span>;</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> g[N][N], dist[N];</span><br><span class="line"><span class="type">bool</span> st[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dijkstra</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dist, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> dist);</span><br><span class="line">    dist[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> t = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j ++)</span><br><span class="line">            <span class="keyword">if</span> (!st[j] &amp;&amp; (t == <span class="number">-1</span> || dist[t] &gt; dist[j])) </span><br><span class="line">                t = j;</span><br><span class="line">        st[t] = <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">// 更新到其他点的距离</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j ++)</span><br><span class="line">            dist[j] = <span class="built_in">min</span>(dist[j], dist[t] + g[t][j]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dist[n] == <span class="number">0x3f3f3f3f</span> ? <span class="number">-1</span> : dist[n];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="built_in">memset</span>(g, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> g);</span><br><span class="line">    <span class="keyword">while</span> (m --)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a, b, c; cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;</span><br><span class="line">        g[a][b] = <span class="built_in">min</span>(g[a][b], c);</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">dijkstra</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-1-4-性能分析"><a href="#4-1-4-性能分析" class="headerlink" title="4.1.4 性能分析"></a>4.1.4 性能分析</h3><ul>
<li><strong>时间复杂度</strong>：$O(n²)$</li>
<li><strong>空间复杂度</strong>：$O(n)$</li>
</ul>
<p>Dijkstra算法是基于贪心策略，当边上带有负值时，该算法并不适用，会进入死循环。</p>
<h2 id="4-2-Floyd算法"><a href="#4-2-Floyd算法" class="headerlink" title="4.2 Floyd算法"></a>4.2 Floyd算法</h2><p>如何求每一对顶点之间的最短路径？</p>
<ol>
<li><p>每次以一个顶点为源点，重复执行Dijkstra算法n次：$T(n)&#x3D;O(n^3)$。</p>
</li>
<li><p>弗洛伊德(Floyd)算法</p>
</li>
</ol>
<p><strong>算法思想</strong>：逐个顶点试探法。</p>
<h3 id="4-2-1-求最短路径步骤-xA"><a href="#4-2-1-求最短路径步骤-xA" class="headerlink" title="4.2.1 求最短路径步骤&#xA;"></a>4.2.1 求最短路径步骤&#xA;</h3><ol>
<li>初始时设置一个n阶方阵，令其对角线元素为0，若存在弧$&lt;V_i,V_j&gt;$，则对应元素为权值；否则为∞。</li>
<li>逐步试着在原直接路径中增加中间顶点，若加入中间点后路径变短，则修改之；否则维持原值。</li>
<li>所有顶点试探完毕，算法结束。</li>
</ol>
<p><img src="/2024/06/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC6%E7%AB%A0%EF%BC%9A%E5%9B%BE/image_MH2j8EZWlF.png"></p>
<p><img src="/2024/06/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC6%E7%AB%A0%EF%BC%9A%E5%9B%BE/image_Wjqn9qnUvo.png"></p>
<h3 id="4-2-2-代码实现"><a href="#4-2-2-代码实现" class="headerlink" title="4.2.2 代码实现"></a>4.2.2 代码实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">210</span>;</span><br><span class="line"><span class="type">int</span> dist[N][N];</span><br><span class="line"><span class="type">int</span> n, m, q;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">floyd</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">1</span>; k &lt;= n; k ++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j ++)</span><br><span class="line">                dist[i][j] = <span class="built_in">min</span>(dist[i][j], dist[i][k] + dist[k][j]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m &gt;&gt; q;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j ++)</span><br><span class="line">            <span class="keyword">if</span> (i == j) dist[i][j] = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">else</span> dist[i][j] = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (m --)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a, b, c; cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;</span><br><span class="line">        dist[a][b] = <span class="built_in">min</span>(dist[a][b], c);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">floyd</span>();</span><br><span class="line">    <span class="keyword">while</span> (q --)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> x, y; cin &gt;&gt; x &gt;&gt; y;</span><br><span class="line">        <span class="keyword">if</span> (dist[x][y] &gt; <span class="number">0x3f3f3f3f</span> / <span class="number">2</span>) cout &lt;&lt; <span class="string">&quot;impossible&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">else</span> cout &lt;&lt; dist[x][y] &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-2-3-性能分析"><a href="#4-2-3-性能分析" class="headerlink" title="4.2.3 性能分析"></a>4.2.3 性能分析</h3><ul>
<li><strong>时间复杂度</strong>：$O(n^3)$，不过由于其代码很紧凑，且不包含其他复杂的数据结构，因此隐含的常数系数是很小的。</li>
<li><strong>空间复杂度</strong>：$O(n^2)$</li>
</ul>
<p>Floyd算法允许图中有带负权值的边，但不允许有包含带负权值的边组成的回路。</p>
<hr>
<h1 id="5-拓扑排序"><a href="#5-拓扑排序" class="headerlink" title="5 拓扑排序"></a>5 拓扑排序</h1><p><strong>AOV网</strong>：用顶点表示活动，用弧表示活动间优先关系的有向图称为顶点表示活动的网（Activity On Vertex network），简称AOV网。</p>
<ul>
<li>若&lt;$v_{i}$, $v_{j}$&gt;是图中有向边，则$v_{i}$是$v_{j}$的直接前驱；$v_{j}$是$v_{i}$的直接后继</li>
<li>AOV网中不允许有回路，这意味着某项活动以自己为先决条件</li>
</ul>
<p><strong>拓扑排序</strong>：把AOV网络中各顶点按照它们相互之间的优先关系排列成一个线性序列的过程叫拓扑排序。</p>
<h2 id="5-1-算法思想"><a href="#5-1-算法思想" class="headerlink" title="5.1 算法思想"></a>5.1 算法思想</h2><ul>
<li>在有向图中选一个没有前驱的顶点且输出之；</li>
<li>从图中删除该顶点和所有以它为尾的弧；</li>
<li>重复上述两步，直至全部顶点均已输出；或者当图中不存在无前驱的顶点为止。</li>
</ul>
<h2 id="5-2-算法过程"><a href="#5-2-算法过程" class="headerlink" title="5.2 算法过程"></a>5.2 算法过程</h2><p><img src="https://pica.zhimg.com/v2-def95e93dd0e7eba3144c688c550e612_1440w.jpg?source=172ae18b"></p>
<h2 id="5-3-代码实现"><a href="#5-3-代码实现" class="headerlink" title="5.3 代码实现"></a>5.3 代码实现</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>;</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> d[N];</span><br><span class="line"><span class="type">int</span> q[N], hh, tt = <span class="number">-1</span>;</span><br><span class="line"><span class="type">int</span> h[N], e[N], ne[N], idx;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">top_sort</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++)</span><br><span class="line">		<span class="keyword">if</span> (!d[i]) q[++ tt] = i;</span><br><span class="line">	<span class="keyword">while</span> (hh &lt;= tt)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> t = q[hh ++];</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = h[t]; i != <span class="number">-1</span>; i = ne[i])</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="type">int</span> j = e[i];</span><br><span class="line">			<span class="keyword">if</span> (-- d[j] == <span class="number">0</span>)</span><br><span class="line">				q[++ tt] = j;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> tt == n - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="keyword">sizeof</span> h);</span><br><span class="line">	cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">	<span class="keyword">while</span> (m --)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> a, b; cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">		d[b] ++;</span><br><span class="line">		e[idx] = b, ne[idx] = h[a], h[a] = idx ++;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">top_sort</span>())</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= tt; i ++)	cout &lt;&lt; q[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	<span class="keyword">else</span> cout &lt;&lt; <span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="5-4-性能分析"><a href="#5-4-性能分析" class="headerlink" title="5.4 性能分析"></a>5.4 性能分析</h2><ul>
<li><strong>空间复杂度</strong>：使用一个辅助队列$Q$，$O(|V|)$</li>
<li><strong>时间复杂度</strong>：从队列中取出每个点的同时还要遍历从它出发的边，所以时间复杂度为$O(|V|+|E|)$</li>
</ul>
<h2 id="5-5-逆拓扑排序"><a href="#5-5-逆拓扑排序" class="headerlink" title="5.5 逆拓扑排序"></a>5.5 逆拓扑排序</h2><p>与上述拓扑排序过程相反，先输出出度为0的点，然后删除所有以该顶点为终点的有向边，直到当前AVO网为空。</p>
<h3 id="5-5-1-具体应用"><a href="#5-5-1-具体应用" class="headerlink" title="5.5.1 具体应用"></a>5.5.1 具体应用</h3><ul>
<li>学生选修课程问题</li>
</ul>
<hr>
<h1 id="6-关键路径"><a href="#6-关键路径" class="headerlink" title="6 关键路径"></a>6 关键路径</h1><p><strong>AOE网（Activity On Edge）</strong>：边表示活动的网。AOE网是一个带权的有向无环图，其中顶点表示事件，弧表示活动，权表示活动持续时间。</p>
<ul>
<li>在AOE网中仅有一个入度为0的顶点，称为<strong>开始结点（源点）</strong>，表示整个工程的开始；</li>
<li>仅存在一个出度为0的顶点，称为<strong>结束顶点（汇点）</strong>，表示整个工程的结束；</li>
</ul>
<p><strong>路径长度</strong>：路径上各活动持续时间之和。</p>
<p><strong>关键路径</strong>：路径长度最长的路径。</p>
<p>完成整个工程的最短时间就是关键路径的长度，即关键路径上各活动花费开销的总和。因为关键活动影响整个工程的时间，因此只要找到关键活动，就找到了关键路径。</p>
<h2 id="6-1-相关变量"><a href="#6-1-相关变量" class="headerlink" title="6.1 相关变量"></a>6.1 相关变量</h2><h3 id="6-1-1-V-e-：事件-V-j-的最早发生时间-V-e-j"><a href="#6-1-1-V-e-：事件-V-j-的最早发生时间-V-e-j" class="headerlink" title="6.1.1 $V_{e}$：事件$V_{j}$的最早发生时间$V_{e}(j)$"></a>6.1.1 $V_{e}$：事件$V_{j}$的最早发生时间$V_{e}(j)$</h3><p>源点的最早发生时间为0，其余任一顶点$V_{j}$的最早发生时间，等于从源点出发沿着各条路径达到$V_{j}$时每条路径上权的累加和的最大值。</p>
<p>$$<br>    Ve(j) &#x3D; \max (Ve(i) + Weight(&lt;i ,j&gt;))<br>$$</p>
<h3 id="6-1-2-V-l-：事件-V-j-的最迟发生时间-V-l-j"><a href="#6-1-2-V-l-：事件-V-j-的最迟发生时间-V-l-j" class="headerlink" title="6.1.2 $V_{l}$：事件$V_{j}$的最迟发生时间$V_{l}(j)$"></a>6.1.2 $V_{l}$：事件$V_{j}$的最迟发生时间$V_{l}(j)$</h3><p>汇点的最迟发生时间$V_{l}[n]$等于汇点的最早发生时间$V_{e}[n]$。其余任一顶点$V_{i}$的最迟发生时间等于从汇点的最迟发生时间中减去从顶点$V_{i}$出发沿着各条路径达到汇点时，每条路径上权的累加和的最大值。</p>
<p>$$<br>    V_l(i) &#x3D; \min {V_l(j) - Weight(&lt;i ,j&gt;)}<br>$$</p>
<p>在计算$V_{l}(k)$时，按从后向前的顺序进行，可以在逆拓扑排序的基础上计算。</p>
<h3 id="6-1-3-e-i-：活动-a-i-的最早开始时间"><a href="#6-1-3-e-i-：活动-a-i-的最早开始时间" class="headerlink" title="6.1.3 $e_{i}$：活动$a_{i}$的最早开始时间"></a>6.1.3 $e_{i}$：活动$a_{i}$的最早开始时间</h3><p>即该事件的起点的最早发生时间。</p>
<h3 id="6-1-4-l-i-：活动-a-i-的最迟开始时间"><a href="#6-1-4-l-i-：活动-a-i-的最迟开始时间" class="headerlink" title="6.1.4 $l_{i}$：活动$a_{i}$的最迟开始时间"></a>6.1.4 $l_{i}$：活动$a_{i}$的最迟开始时间</h3><p>该活动弧的终点所表示的事件的最迟发生事件与该活动所需事件之差。</p>
<h3 id="6-1-5-时间余量"><a href="#6-1-5-时间余量" class="headerlink" title="6.1.5 时间余量"></a>6.1.5 时间余量</h3><p>时间余量是指一个活动的最迟开始时间和最早开始时间的差额。其中余量为0的活动为关键活动。</p>
<h2 id="6-2-算法思想"><a href="#6-2-算法思想" class="headerlink" title="6.2 算法思想"></a>6.2 算法思想</h2><p>求关键路径的算法步骤如下：</p>
<ol>
<li>从源点出发，令ve(源点) &#x3D; 0，按拓扑有序求其余顶点的最早发生时间ve()。</li>
<li>从汇点出发，令vl(汇点) &#x3D; ve(汇点)，按逆拓扑有序求其余顶点的最迟发生时间vl()。</li>
<li>根据各顶点的ve()值求所有弧的最早开始时间e()。</li>
<li>根据各顶点的vl()值求所有弧的最早开始时间l()。</li>
<li>求AOE网中所有活动的差额d()，找出所有d() &#x3D; 0的活动构成关键路径。</li>
</ol>
<h3 id="6-2-1-注意"><a href="#6-2-1-注意" class="headerlink" title="6.2.1 注意"></a>6.2.1 注意</h3><ul>
<li><strong>关键路径上的所有活动都是关键活动，可以通过加快关键活动来缩短整个工程的工期</strong>，但是不能任意缩短关键活动，因为缩短到一定程度，该关键活动就可能变成非关键活动。</li>
<li><strong>网中的关键路径并不唯一</strong>。对于含有多条关键路径的网中，只有加快那些包括在所有关键路径上的关键活动才能达到缩短工期的目的。</li>
</ul>
<h2 id="6-3-算法过程"><a href="#6-3-算法过程" class="headerlink" title="6.3 算法过程"></a>6.3 算法过程</h2><p><img src="https://img-blog.csdnimg.cn/20200610180344442.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjA3Mjc3MQ==,size_16,color_FFFFFF,t_70"></p>
<h2 id="6-4-代码实现"><a href="#6-4-代码实现" class="headerlink" title="6.4 代码实现"></a>6.4 代码实现</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>;</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> h[N], inverse_h[N], e[N], ne[N], w[N], idx;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> in_d[N], out_d[N];</span><br><span class="line"><span class="type">int</span> q[N], hh, tt = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> list[], <span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	e[idx] = b, ne[idx] = list[a], w[idx] = c, list[a] = idx ++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> ve[N];  <span class="comment">// 顶点的最早发生时间</span></span><br><span class="line"><span class="comment">// 按照拓扑排序求解所有顶点的最早发生时间</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">top_sort</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	hh = <span class="number">0</span>, tt = <span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++)</span><br><span class="line">		<span class="keyword">if</span> (!in_d[i]) q[++ tt] = i;</span><br><span class="line">	<span class="keyword">while</span> (hh &lt;= tt)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">auto</span> t = q[hh ++];</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = h[t]; i != <span class="number">-1</span>; i = ne[i])</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="type">int</span> j = e[i];</span><br><span class="line">			ve[j] = <span class="built_in">max</span>(ve[j], ve[t] + w[i]);</span><br><span class="line">			<span class="keyword">if</span> (-- in_d[j] == <span class="number">0</span>) q[++ tt] = j;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++)</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;ver:%d ve:%d\n&quot;</span>, i, ve[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> vl[N];  <span class="comment">// 求顶点的最迟发生时间</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">inverse_top</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">memset</span>(vl, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> vl);</span><br><span class="line">	hh = <span class="number">0</span>, tt = <span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++)</span><br><span class="line">		<span class="keyword">if</span> (!out_d[i]) q[++ tt] = i;</span><br><span class="line">	vl[q[hh]] = ve[q[hh]];</span><br><span class="line">	<span class="keyword">while</span> (hh &lt;= tt)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">auto</span> t = q[hh ++];</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = inverse_h[t]; i != <span class="number">-1</span>; i = ne[i])</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="type">int</span> j = e[i];</span><br><span class="line">			vl[j] = <span class="built_in">min</span>(vl[j], vl[t] - w[i]);</span><br><span class="line">			<span class="keyword">if</span> (-- out_d[j] == <span class="number">0</span>) q[++ tt] = j;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++)</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;ver:%d vl:%d\n&quot;</span>, i, vl[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> ee[N];  <span class="comment">// 得到每个边的最早开始时间</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">get_e</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	hh = <span class="number">0</span>, tt = <span class="number">-1</span>;</span><br><span class="line">	q[++ tt] = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span> (hh &lt;= tt)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">auto</span> t = q[hh ++];</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = h[t]; i != <span class="number">-1</span>; i = ne[i])</span><br><span class="line">			ee[i] = ve[t];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++)</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;ver:%d vl:%d\n&quot;</span>, i, vl[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="keyword">sizeof</span> h);</span><br><span class="line">	<span class="built_in">memset</span>(inverse_h, <span class="number">-1</span>, <span class="keyword">sizeof</span> inverse_h);</span><br><span class="line">	cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">	<span class="keyword">while</span> (m --)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> a, b, c; cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;</span><br><span class="line">		<span class="built_in">add</span>(h, a, b, c); <span class="built_in">add</span>(inverse_h, b, a, c);</span><br><span class="line">		out_d[a] ++, in_d[b] ++;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">top_sort</span>();</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;--------&quot;</span> &lt;&lt; endl;</span><br><span class="line">	<span class="built_in">inverse_top</span>();</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;--------&quot;</span> &lt;&lt; endl;</span><br><span class="line">	<span class="built_in">get_e</span>();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="http://zhouzimu.top">弘树</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="http://zhouzimu.top/2024/06/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC6%E7%AB%A0%EF%BC%9A%E5%9B%BE/">http://zhouzimu.top/2024/06/09/数据结构第6章：图/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://zhouzimu.top" target="_blank">诺亚方舟</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</a></div><div class="post_share"><div class="social-share" data-image="https://www.dotcpp.com/oj/ueditor/php/upload/image/20221014/1665738230388021.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i>码字不易，如果对你有帮助的话请喝一杯奶茶吧~</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/img/wechat.png" target="_blank"><img class="post-qr-code-img" src="/img/wechat.png" alt="微信"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="/img/alipay.png" target="_blank"><img class="post-qr-code-img" src="/img/alipay.png" alt="支付宝"/></a><div class="post-qr-code-desc">支付宝</div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2024/06/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC5%E7%AB%A0%EF%BC%9A%E6%A0%91%E4%B8%8E%E4%BA%8C%E5%8F%89%E6%A0%91/" title="数据结构第5章：树与二叉树"><img class="cover" src="https://pic1.zhimg.com/v2-0dc735ac5aa550f1093cc9c9785a1095_1200x500.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">数据结构第5章：树与二叉树</div></div></a></div><div class="next-post pull-right"><a href="/2024/06/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC7%E7%AB%A0%EF%BC%9A%E6%9F%A5%E6%89%BE/" title="数据结构第7章：查找"><img class="cover" src="https://pic1.zhimg.com/v2-48dba9aaef7d9b8d8df0feba842f86d6_r.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">数据结构第7章：查找</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2024/06/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC4%E7%AB%A0%EF%BC%9A%E4%B8%B2/" title="数据结构第4章：串"><img class="cover" src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9jZG4ubmxhcmsuY29tL3l1cXVlLzAvMjAxOS9wbmcvMTI5NTA0LzE1NjQxMjU1ODY0MTctOGE3YWY0MzUtYWU4Yi00OWYyLTkxZDEtNmRiZmYzZmQwZjgyLnBuZw#align=left&display=inline&height=545&name=image.png&originHeight=545&originWidth=910&size=291927&status=done&width=910" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-06-10</div><div class="title">数据结构第4章：串</div></div></a></div><div><a href="/2024/06/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC5%E7%AB%A0%EF%BC%9A%E6%A0%91%E4%B8%8E%E4%BA%8C%E5%8F%89%E6%A0%91/" title="数据结构第5章：树与二叉树"><img class="cover" src="https://pic1.zhimg.com/v2-0dc735ac5aa550f1093cc9c9785a1095_1200x500.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-06-10</div><div class="title">数据结构第5章：树与二叉树</div></div></a></div><div><a href="/2024/06/11/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC3%E7%AB%A0%EF%BC%9A%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/" title="数据结构第3章：栈和队列"><img class="cover" src="https://i.loli.net/2019/08/18/xqbQD8UEW1cRPFs.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-06-11</div><div class="title">数据结构第3章：栈和队列</div></div></a></div><div><a href="/2024/06/06/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC8%E7%AB%A0%EF%BC%9A%E6%8E%92%E5%BA%8F/" title="数据结构第8章：排序"><img class="cover" src="https://itimetraveler.github.io/gallery/sort-algorithms/2016-07-15_%E5%B8%B8%E7%94%A8%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-06-06</div><div class="title">数据结构第8章：排序</div></div></a></div><div><a href="/2024/06/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC7%E7%AB%A0%EF%BC%9A%E6%9F%A5%E6%89%BE/" title="数据结构第7章：查找"><img class="cover" src="https://pic1.zhimg.com/v2-48dba9aaef7d9b8d8df0feba842f86d6_r.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-06-09</div><div class="title">数据结构第7章：查找</div></div></a></div><div><a href="/2024/08/01/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E9%9D%A2%E7%BB%8F1%EF%BC%9A%E7%BB%AA%E8%AE%BA/" title="数据结构面经1：绪论"><img class="cover" src="https://leepoo.top/img/1646583341588.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-08-01</div><div class="title">数据结构面经1：绪论</div></div></a></div></div></div><hr class="custom-hr"/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="utterances-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/pic_editor_1635545191.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">弘树</div><div class="author-info__description">在我坚定无比的内心，总以最坚强的节奏解开案情</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">123</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">45</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">17</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/NoyeArk"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/NoyeArk" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="mailto:horiki0@qq.com" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #4a7dbe;"></i></a><a class="social-icon" href="https://leetcode.cn/u/horiki/" target="_blank" title="Leetcode"><i class="fas fa-l" style="color: #59e285;"></i></a><a class="social-icon" href="https://www.kaggle.com/horiki" target="_blank" title="Kaggle"><i class="fas fa-k" style="color: #4a7dbe;"></i></a></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc" style="font-size: 15px;"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#1-%E5%9B%BE%E7%9A%84%E5%AD%98%E5%82%A8"><span class="toc-text">1 图的存储</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-1-%E9%82%BB%E6%8E%A5%E7%9F%A9%E9%98%B5"><span class="toc-text">1.1 邻接矩阵</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-2-%E9%82%BB%E6%8E%A5%E8%A1%A8"><span class="toc-text">1.2 邻接表</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-1-%E9%82%BB%E6%8E%A5%E8%A1%A8%E8%A1%A8%E7%A4%BA%E7%9A%84%E7%89%B9%E7%82%B9"><span class="toc-text">1.2.1 邻接表表示的特点</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-3-%E5%8D%81%E5%AD%97%E9%93%BE%E8%A1%A8"><span class="toc-text">1.3 十字链表</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-4-%E9%82%BB%E6%8E%A5%E5%A4%9A%E9%87%8D%E8%A1%A8"><span class="toc-text">1.4 邻接多重表</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#2-%E5%9B%BE%E7%9A%84%E9%81%8D%E5%8E%86"><span class="toc-text">2 图的遍历</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#2-1-DFS"><span class="toc-text">2.1 DFS</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-1-DFS%E4%BB%A3%E7%A0%81%E6%A8%A1%E6%9D%BF"><span class="toc-text">2.1.1 DFS代码模板</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-2-%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90"><span class="toc-text">2.1.2 性能分析</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-2-BFS"><span class="toc-text">2.2 BFS</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-1-BFS%E4%BB%A3%E7%A0%81%E6%A8%A1%E6%9D%BF"><span class="toc-text">2.2.1 BFS代码模板</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-2-%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90"><span class="toc-text">2.2.2 性能分析</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#3-%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91"><span class="toc-text">3 最小生成树</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#3-1-%E6%99%AE%E5%88%A9%E5%A7%86%EF%BC%88Prim%EF%BC%89%E7%AE%97%E6%B3%95"><span class="toc-text">3.1 普利姆（Prim）算法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-1-%E7%AE%97%E6%B3%95%E6%80%9D%E6%83%B3"><span class="toc-text">3.1.1 算法思想</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-2-%E7%AE%97%E6%B3%95%E8%BF%87%E7%A8%8B"><span class="toc-text">3.1.2 算法过程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-3-%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0"><span class="toc-text">3.1.3 代码实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-4-%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90"><span class="toc-text">3.1.4 性能分析</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-2-%E5%85%8B%E9%B2%81%E6%96%AF%E5%8D%A1%E5%B0%94%EF%BC%88Kruskal%EF%BC%89%E7%AE%97%E6%B3%95"><span class="toc-text">3.2 克鲁斯卡尔（Kruskal）算法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-1-%E7%AE%97%E6%B3%95%E6%80%9D%E6%83%B3"><span class="toc-text">3.2.1 算法思想</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-2-%E7%AE%97%E6%B3%95%E8%BF%87%E7%A8%8B"><span class="toc-text">3.2.2 算法过程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-3-%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0"><span class="toc-text">3.2.3 代码实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-4-%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90"><span class="toc-text">3.2.4 性能分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-5-%E5%85%B7%E4%BD%93%E5%BA%94%E7%94%A8"><span class="toc-text">3.2.5 具体应用</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#4-%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84"><span class="toc-text">4 最短路径</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#4-1-Dijkstra%E7%AE%97%E6%B3%95"><span class="toc-text">4.1 Dijkstra算法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-1-%E7%AE%97%E6%B3%95%E6%80%9D%E6%83%B3"><span class="toc-text">4.1.1 算法思想</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-2-%E6%B1%82%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E6%AD%A5%E9%AA%A4-xD"><span class="toc-text">4.1.2 求最短路径步骤</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-3-%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0"><span class="toc-text">4.1.3 代码实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-4-%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90"><span class="toc-text">4.1.4 性能分析</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-2-Floyd%E7%AE%97%E6%B3%95"><span class="toc-text">4.2 Floyd算法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-1-%E6%B1%82%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E6%AD%A5%E9%AA%A4-xA"><span class="toc-text">4.2.1 求最短路径步骤
</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-2-%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0"><span class="toc-text">4.2.2 代码实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-3-%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90"><span class="toc-text">4.2.3 性能分析</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#5-%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F"><span class="toc-text">5 拓扑排序</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#5-1-%E7%AE%97%E6%B3%95%E6%80%9D%E6%83%B3"><span class="toc-text">5.1 算法思想</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-2-%E7%AE%97%E6%B3%95%E8%BF%87%E7%A8%8B"><span class="toc-text">5.2 算法过程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-3-%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0"><span class="toc-text">5.3 代码实现</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-4-%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90"><span class="toc-text">5.4 性能分析</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-5-%E9%80%86%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F"><span class="toc-text">5.5 逆拓扑排序</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-5-1-%E5%85%B7%E4%BD%93%E5%BA%94%E7%94%A8"><span class="toc-text">5.5.1 具体应用</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#6-%E5%85%B3%E9%94%AE%E8%B7%AF%E5%BE%84"><span class="toc-text">6 关键路径</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#6-1-%E7%9B%B8%E5%85%B3%E5%8F%98%E9%87%8F"><span class="toc-text">6.1 相关变量</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#6-1-1-V-e-%EF%BC%9A%E4%BA%8B%E4%BB%B6-V-j-%E7%9A%84%E6%9C%80%E6%97%A9%E5%8F%91%E7%94%9F%E6%97%B6%E9%97%B4-V-e-j"><span class="toc-text">6.1.1 $V_{e}$：事件$V_{j}$的最早发生时间$V_{e}(j)$</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-1-2-V-l-%EF%BC%9A%E4%BA%8B%E4%BB%B6-V-j-%E7%9A%84%E6%9C%80%E8%BF%9F%E5%8F%91%E7%94%9F%E6%97%B6%E9%97%B4-V-l-j"><span class="toc-text">6.1.2 $V_{l}$：事件$V_{j}$的最迟发生时间$V_{l}(j)$</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-1-3-e-i-%EF%BC%9A%E6%B4%BB%E5%8A%A8-a-i-%E7%9A%84%E6%9C%80%E6%97%A9%E5%BC%80%E5%A7%8B%E6%97%B6%E9%97%B4"><span class="toc-text">6.1.3 $e_{i}$：活动$a_{i}$的最早开始时间</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-1-4-l-i-%EF%BC%9A%E6%B4%BB%E5%8A%A8-a-i-%E7%9A%84%E6%9C%80%E8%BF%9F%E5%BC%80%E5%A7%8B%E6%97%B6%E9%97%B4"><span class="toc-text">6.1.4 $l_{i}$：活动$a_{i}$的最迟开始时间</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-1-5-%E6%97%B6%E9%97%B4%E4%BD%99%E9%87%8F"><span class="toc-text">6.1.5 时间余量</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-2-%E7%AE%97%E6%B3%95%E6%80%9D%E6%83%B3"><span class="toc-text">6.2 算法思想</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#6-2-1-%E6%B3%A8%E6%84%8F"><span class="toc-text">6.2.1 注意</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-3-%E7%AE%97%E6%B3%95%E8%BF%87%E7%A8%8B"><span class="toc-text">6.3 算法过程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-4-%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0"><span class="toc-text">6.4 代码实现</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline" style="font-size: 17px;"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list" style="font-size: 16px;"><div class="aside-list-item"><a class="thumbnail" href="/2025/05/02/5-%E6%95%B0%E6%8D%AE%E9%9B%86/" title="「HFLLM」5-数据集"><img src="https://cdn.mos.cms.futurecdn.net/gHfBJ6FBHKnLbW36hEDvgV.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="「HFLLM」5-数据集"/></a><div class="content"><a class="title" href="/2025/05/02/5-%E6%95%B0%E6%8D%AE%E9%9B%86/" title="「HFLLM」5-数据集">「HFLLM」5-数据集</a><time datetime="2025-05-02T08:26:25.000Z" title="发表于 2025-05-02 16:26:25">2025-05-02</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/05/01/3-%E5%BE%AE%E8%B0%83%E9%A2%84%E8%AE%AD%E7%BB%83%E6%A8%A1%E5%9E%8B/" title="「HFLLM」3. 微调预训练模型"><img src="https://venturebeat.com/wp-content/uploads/2023/05/Untitled-design-78.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="「HFLLM」3. 微调预训练模型"/></a><div class="content"><a class="title" href="/2025/05/01/3-%E5%BE%AE%E8%B0%83%E9%A2%84%E8%AE%AD%E7%BB%83%E6%A8%A1%E5%9E%8B/" title="「HFLLM」3. 微调预训练模型">「HFLLM」3. 微调预训练模型</a><time datetime="2025-05-01T02:51:22.000Z" title="发表于 2025-05-01 10:51:22">2025-05-01</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/02/17/%E8%AE%BA%E6%96%87%E7%B2%BE%E8%AF%BB9%EF%BC%9AADSNet/" title="论文精读9：ADSNet"><img src="https://i.ytimg.com/vi/v5BoeTyOAhM/hq720.jpg?sqp=-oaymwE7CK4FEIIDSFryq4qpAy0IARUAAAAAGAElAADIQj0AgKJD8AEB-AH-CYACzgWKAgwIABABGFsgYShlMA8=&amp;rs=AOn4CLChXkjgk_egO-1uGInclI_lQe_MMg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="论文精读9：ADSNet"/></a><div class="content"><a class="title" href="/2025/02/17/%E8%AE%BA%E6%96%87%E7%B2%BE%E8%AF%BB9%EF%BC%9AADSNet/" title="论文精读9：ADSNet">论文精读9：ADSNet</a><time datetime="2025-02-17T09:09:52.000Z" title="发表于 2025-02-17 17:09:52">2025-02-17</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/01/27/2024%E5%B9%B4AI%E5%B9%B4%E5%BA%A6%E5%85%B3%E9%94%AE%E8%AF%8D/" title="2024年AI年度关键词"><img src="https://image.uisdc.com/wp-content/uploads/2025/01/banner2025012108482456.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="2024年AI年度关键词"/></a><div class="content"><a class="title" href="/2025/01/27/2024%E5%B9%B4AI%E5%B9%B4%E5%BA%A6%E5%85%B3%E9%94%AE%E8%AF%8D/" title="2024年AI年度关键词">2024年AI年度关键词</a><time datetime="2025-01-27T11:03:16.000Z" title="发表于 2025-01-27 19:03:16">2025-01-27</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url('https://www.dotcpp.com/oj/ueditor/php/upload/image/20221014/1665738230388021.jpg')"><div id="footer-wrap" style="padding: 5px 5px;"><div class="copyright">&copy;2024 - 2025 By 弘树</div><div id="running-time" style="font-size: 14px;"><script>setInterval(() => {
  let create_time = Math.round((new Date(2024, 1, 23).getTime()) / 1000);
  let timestamp = Math.round((new Date().getTime()) / 1000);
  let second = timestamp - create_time;
  let time = new Array(0, 0, 0, 0, 0);
  if (second >= 365 * 24 * 3600) {
      time[0] = parseInt(second / (365 * 24 * 3600));
      second %= 365 * 24 * 3600;
  }
  if (second >= 24 * 3600) {
      time[1] = parseInt(second / (24 * 3600));
      second %= 24 * 3600;
  }
  if (second >= 3600) {
      time[2] = parseInt(second / 3600);
      second %= 3600;
  }
  if (second >= 60) {
      time[3] = parseInt(second / 60);
      second %= 60;
  }
  if (second > 0) {
      time[4] = second;
  }
  currentTimeHtml = "本站已安全运行 " +
      time[0] + " 年 " +
      (time[1] + 31) + " 天 " +
      time[2] + " 时 " +
      time[3] + " 分 " +
      time[4] + " 秒";
  document.getElementById("running-time").innerHTML = currentTimeHtml;
  }, 1000);</script></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=4.12.0"></script><script src="/js/main.js?v=4.12.0"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.32/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"><script>if (!window.MathJax) {
  window.MathJax = {
    tex: {
      inlineMath: [['$', '$'], ['\\(', '\\)']],
      tags: 'ams'
    },
    chtml: {
      scale: 1.1
    },
    options: {
      renderActions: {
        findScript: [10, doc => {
          for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
            const display = !!node.type.match(/; *mode=display/)
            const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
            const text = document.createTextNode('')
            node.parentNode.replaceChild(text, node)
            math.start = {node: text, delim: '', n: 0}
            math.end = {node: text, delim: '', n: 0}
            doc.math.push(math)
          }
        }, '']
      }
    }
  }
  
  const script = document.createElement('script')
  script.src = 'https://cdn.jsdelivr.net/npm/mathjax@3.2.2/es5/tex-mml-chtml.min.js'
  script.id = 'MathJax-script'
  script.async = true
  document.head.appendChild(script)
} else {
  MathJax.startup.document.state(0)
  MathJax.texReset()
  MathJax.typesetPromise()
}</script><script>(() => {
  const loadUtterances = () => {
    let ele = document.createElement('script')
    ele.id = 'utterances_comment'
    ele.src = 'https://utteranc.es/client.js'
    ele.setAttribute('repo', 'NoyeArk/noyeark.github.io')
    ele.setAttribute('issue-term', 'pathname')
    const nowTheme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'photon-dark' : 'github-light'
    ele.setAttribute('theme', nowTheme)
    ele.crossOrigin = 'anonymous'
    ele.async = true
    document.getElementById('utterances-wrap').appendChild(ele)
  }

  const utterancesTheme = theme => {
    const iframe = document.querySelector('.utterances-frame')
    if (iframe) {
      const theme = theme === 'dark' ? 'photon-dark' : 'github-light'
      const message = {
        type: 'set-theme',
        theme: theme
      };
      iframe.contentWindow.postMessage(message, 'https://utteranc.es');
    }
  }

  btf.addGlobalFn('themeChange', utterancesTheme, 'utterances')

  if ('Utterances' === 'Utterances' || !false) {
    if (false) btf.loadComment(document.getElementById('utterances-wrap'), loadUtterances)
    else loadUtterances()
  } else {
    window.loadOtherComment = loadUtterances
  }
})()</script></div><script src="/js/jquery.js"></script><script src="/js/footer.js"></script><script src="/js/nav.js"></script><script>let tianliGPT_postSelector = '\#post \#article-container';let tianliGPT_key = 'iyiSf8ljbaf';</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js?v=4.12.0"></script></div></div></body></html>