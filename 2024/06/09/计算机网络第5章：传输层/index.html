<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>计算机网络第5章：传输层 | 诺亚方舟</title><meta name="author" content="弘树"><meta name="copyright" content="弘树"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="1 传输层协议概述 1.1 进程之间的通信 从通信和信息处理的角度看，运输层向它上面的应用层提供通信服务，它属于面向通信部分的最高层，同时也是用户功能中的最低层。 当网络的边缘部分中的两个主机使用网络的核心部分的功能进行端到端的通信时，只有位于网络边缘部分的主机的协议栈才有运输层，而网络核心部分中的路由器在转发分组时都只用到下三层的功能。  运输层为相互通信的应用进程提供了逻辑通信：  1.1.1">
<meta property="og:type" content="article">
<meta property="og:title" content="计算机网络第5章：传输层">
<meta property="og:url" content="http://zhouzimu.top/2024/06/09/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC5%E7%AB%A0%EF%BC%9A%E4%BC%A0%E8%BE%93%E5%B1%82/index.html">
<meta property="og:site_name" content="诺亚方舟">
<meta property="og:description" content="1 传输层协议概述 1.1 进程之间的通信 从通信和信息处理的角度看，运输层向它上面的应用层提供通信服务，它属于面向通信部分的最高层，同时也是用户功能中的最低层。 当网络的边缘部分中的两个主机使用网络的核心部分的功能进行端到端的通信时，只有位于网络边缘部分的主机的协议栈才有运输层，而网络核心部分中的路由器在转发分组时都只用到下三层的功能。  运输层为相互通信的应用进程提供了逻辑通信：  1.1.1">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://pic1.zhimg.com/v2-2159a954d03d90c2d869bf962a7ef775_720w.jpg?source=172ae18b">
<meta property="article:published_time" content="2024-06-09T02:16:00.000Z">
<meta property="article:modified_time" content="2024-07-31T08:25:10.000Z">
<meta property="article:author" content="弘树">
<meta property="article:tag" content="计算机网络">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://pic1.zhimg.com/v2-2159a954d03d90c2d869bf962a7ef775_720w.jpg?source=172ae18b"><link rel="shortcut icon" href="/img/favicon.jpg"><link rel="canonical" href="http://zhouzimu.top/2024/06/09/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC5%E7%AB%A0%EF%BC%9A%E4%BC%A0%E8%BE%93%E5%B1%82/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css?v=4.12.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.5.1/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.32/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":true,"top_n_per_article":1,"unescape":true,"languages":{"hits_empty":"找不到您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":50,"languages":{"author":"作者: 弘树","link":"链接: ","source":"来源: 诺亚方舟","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.11.0/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '计算机网络第5章：传输层',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-07-31 16:25:10'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
        if (t === 'dark') activateDarkMode()
        else if (t === 'light') activateLightMode()
      
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><link rel="stylesheet" href="/css/myStyle.css"><link rel="stylesheet" href="/css/tianli_gpt.css"><meta name="generator" content="Hexo 6.3.0"><link href="https://cdn.bootcss.com/KaTeX/0.11.1/katex.min.css" rel="stylesheet" /></head><body><div id="loading-box"><div class="wizard-scene"><div class="wizard-objects"><div class="wizard-square"></div><div class="wizard-circle"></div><div class="wizard-triangle"></div></div><div class="wizard"><div class="wizard-body"></div><div class="wizard-right-arm"><div class="wizard-right-hand"></div></div><div class="wizard-left-arm"><div class="wizard-left-hand"></div></div><div class="wizard-head"><div class="wizard-beard"></div><div class="wizard-face"><div class="wizard-adds"></div></div><div class="wizard-hat"><div class="wizard-hat-of-the-hat"></div><div class="wizard-four-point-star --first"></div><div class="wizard-four-point-star --second"></div><div class="wizard-four-point-star --third"></div></div></div></div></div></div><script>(()=>{
  const $loadingBox = document.getElementById('loading-box')
  const $body = document.body
  const preloader = {
    endLoading: () => {
      $body.style.overflow = ''
      $loadingBox.classList.add('loaded')
    },
    initLoading: () => {
      $body.style.overflow = 'hidden'
      $loadingBox.classList.remove('loaded')
    }
  }

  preloader.initLoading()
  window.addEventListener('load',() => { preloader.endLoading() })

  if (false) {
    document.addEventListener('pjax:send', () => { preloader.initLoading() })
    document.addEventListener('pjax:complete', () => { preloader.endLoading() })
  }
})()</script><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/pic_editor_1635545191.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">122</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">45</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">17</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 其他</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><i class="fa-fw fas fa-asterisk"></i><span> 归档</span></a></li><li><a class="site-page child" href="/update/"><i class="fa-fw fas fa-archive"></i><span> 更新日志</span></a></li></ul></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg fixed" id="page-header" style="background-image: url('https://pic1.zhimg.com/v2-2159a954d03d90c2d869bf962a7ef775_720w.jpg?source=172ae18b')"><nav id="nav"><span id="blog-info"><a href="/" title="诺亚方舟"><span class="site-name">诺亚方舟</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 其他</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><i class="fa-fw fas fa-asterisk"></i><span> 归档</span></a></li><li><a class="site-page child" href="/update/"><i class="fa-fw fas fa-archive"></i><span> 更新日志</span></a></li></ul></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">计算机网络第5章：传输层</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="fa-fw post-meta-icon far fa-calendar-alt"></i><span class="post-meta-label">发表于</span><time datetime="2024-06-09T02:16:00.000Z" title="发表于 2024-06-09 10:16:00">2024-06-09</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E4%B8%93%E4%B8%9A%E8%AF%BE/">专业课</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">11.3k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>35分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="计算机网络第5章：传输层"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1>1 传输层协议概述</h1>
<h2 id="1-1-进程之间的通信">1.1 进程之间的通信</h2>
<p>从通信和信息处理的角度看，运输层向它上面的应用层提供通信服务，它属于面向通信部分的最高层，同时也是用户功能中的最低层。</p>
<p>当网络的边缘部分中的两个主机使用网络的核心部分的功能进行端到端的通信时，只有位于网络边缘部分的主机的协议栈才有运输层，而网络核心部分中的路由器在转发分组时都只用到下三层的功能。 </p>
<p>运输层为相互通信的应用进程提供了逻辑通信：</p>
<p><img src="image_6qNRgkRCIy.png" alt=""></p>
<h3 id="1-1-1-应用进程之间的通信">1.1.1 应用进程之间的通信</h3>
<p>两个主机进行通信实际上就是两个主机中的应用进程互相通信。 </p>
<p>应用进程之间的通信又称为<strong>端到端的通信</strong>。 </p>
<p>运输层的一个很重要的功能就是复用和分用。应用层不同进程的报文通过不同的端口向下交到运输层，再往下就共用网络层提供的服务。</p>
<p>“运输层提供应用进程间的逻辑通信”。“逻辑通信”的意思是：运输层之间的通信好像是沿水平方向传送数据。但事实上这两个运输层之间并没有一条水平方向的物理连接。</p>
<p>运输层协议和网络层协议的主要区别：</p>
<p><img src="image_OiMBkJAT-z.png" alt=""></p>
<p>在运输层有一个很重要的功能——<strong>复用和分用</strong>。</p>
<ul>
<li>复用是指发送方不同的应用进程都可以使用同一个运输层协议传送数据</li>
<li>分用是指接收方的运输层在剥去报文的首部后能够把这些数据正确交付目的应用进程</li>
</ul>
<h3 id="1-1-2-运输层的主要功能">1.1.2 运输层的主要功能</h3>
<ol>
<li>
<p>运输层为应用进程之间提供端到端的逻辑通信（但网络层是为主机之间提供逻辑通信）。</p>
</li>
<li>
<p>运输层还要对收到的报文进行差错检测。</p>
</li>
</ol>
<p>运输层需要有两种不同的运输协议，即面向连接的 TCP 和无连接的 UDP。   </p>
<p>运输层向高层用户屏蔽了下面网络核心的细节（如网络拓扑、所采用的路由选择协议等），它使<strong>应用进程</strong>看见的就是好像在两个运输层实体之间有一条端到端的逻辑通信信道。</p>
<ul>
<li>当运输层采用面向连接的 TCP 协议时，尽管下面的网络是不可靠的（只提供尽最大努力服务），但这种逻辑通信信道就相当于一条<strong>全双工</strong>的可靠信道。</li>
<li>当运输层采用无连接的 UDP 协议时，这种逻辑通信信道是一条<strong>不可靠信道</strong>。 </li>
</ul>
<h2 id="1-2-运输层的两个主要协议">1.2 运输层的两个主要协议</h2>
<p>TCP/IP 的运输层有两个不同的协议：</p>
<ol>
<li>
<p>用户数据报协议 UDP  (User Datagram Protocol)</p>
</li>
<li>
<p>传输控制协议 TCP (Transmission Control Protocol)</p>
</li>
</ol>
<p><img src="image_inPlz0AbMp.png" alt=""></p>
<p>两个对等运输实体在通信时传送的数据单位叫作运输协议数据单元 TPDU (Transport Protocol Data Unit)。</p>
<p>TCP 传送的数据单位协议是 TCP 报文段（segment）。</p>
<p>UDP 传送的数据单位协议是 UDP 报文或用户数据报。 </p>
<ol>
<li>UDP 在传送数据之前不需要先建立连接。对方的运输层在收到 UDP 报文后，不需要给出任何确认。虽然 UDP<strong>不提供可靠交付</strong>，但在某些情况下 UDP 是一种最有效的工作方式。</li>
<li>TCP 则提供<strong>面向连接</strong>的服务。TCP 不提供广播或多播服务。由于 TCP 要提供可靠的、面向连接的运输服务，因此不可避免地增加了许多的开销。这不仅使协议数据单元的首部增大很多，还要占用许多的处理机资源。  </li>
</ol>
<p>运输层的 UDP 用户数据报与网际层的IP数据报有很大区别。IP 数据报要经过互连网中许多路由器的存储转发，但 UDP 用户数据报是在运输层的端到端抽象的逻辑信道中传送的。</p>
<p>TCP 报文段是在运输层抽象的端到端逻辑信道中传送，这种信道是可靠的全双工信道。<strong>但这样的信道却不知道究竟经过了哪些路由器，而这些路由器也根本不知道上面的运输层是否建立了 TCP 连接</strong>。 </p>
<h2 id="1-3-运输层的端口">1.3 运输层的端口</h2>
<p>运行在计算机中的进程是用进程标识符来标志的。</p>
<p>运行在应用层的各种应用进程却不应当让计算机操作系统指派它的进程标识符。这是因为<strong>在因特网上使用的计算机的操作系统种类很多，而不同的操作系统又使用不同格式的进程标识符</strong>。</p>
<p>为了使运行不同操作系统的计算机的应用进程能够互相通信，就必须用统一的方法对 TCP/IP 体系的应用进程进行标志。 </p>
<p>由于进程的创建和撤销都是动态的，发送方几乎无法识别其他机器上的进程。有时我们会改换接收报文的进程，但并不需要通知所有发送方。</p>
<p>我们往往需要利用目的主机提供的功能来识别终点，而不需要知道实现这个功能的进程是哪一个（例如，要和互联网上某个邮件服务器联系，但并不一定要知道这个服务器功能是由目的主机的哪个进程实现的）。</p>
<p>当应用层要发送数据时，应用进程就把数据发送到适当的端口，然后运输层从该端口读取数据，进行后续的处理（把数据发送到目的主机）。当运输层收到来自对方主机的户据时，就把数据发送到适当的端口，然后应用进程就从该端口读取数据。因此，<strong>端口必须有一定容量的缓存来暂时存放数据</strong>。</p>
<h3 id="1-3-1-端口号">1.3.1 端口号</h3>
<p>解决这个问题的方法就是在运输层使用<strong>协议端口</strong>（protocol port number），或通常简称为端口（port）。</p>
<p>虽然通信的终点是应用进程，但我们可以把端口想象是通信的终点，因为我们只要把要传送的报文交到目的主机的某一个合适的目的端口，剩下的工作（即最后交付目的进程）就由 TCP 来完成。</p>
<p>端口用一个 16 位端口号进行标志。</p>
<blockquote>
<p>端口号只具有本地意义，即端口号只是为了标志本计算机应用层中的各进程。在因特网中不同计算机的相同端口号是没有联系的。</p>
</blockquote>
<h3 id="1-3-2-软件端口与硬件端口">1.3.2 软件端口与硬件端口</h3>
<ul>
<li>在协议栈层间的抽象的协议端口是<strong>软件端口</strong>。</li>
<li>路由器或交换机上的端口是<strong>硬件端口</strong>。</li>
</ul>
<p>硬件端口是不同硬件设备进行交互的接口，而软件端口是应用层的各种协议进程与运输实体进行层间交互的一种地址。 </p>
<h3 id="1-3-3-三类端口">1.3.3 三类端口</h3>
<ol>
<li><strong>熟知端口</strong>，数值一般为 0~1023。</li>
<li><strong>登记端口号</strong>，数值为1024~49151，为没有熟知端口号的应用程序使用的。使用这个范围的端口号必须在 IANA 登记，以防止重复。</li>
<li><strong>客户端口号或短暂端口号</strong>，数值为49152~65535，留给客户进程选择暂时使用。当服务器进程收到客户进程的报文时，就知道了客户进程所使用的动态端口号。通信结束后，这个端口号可供其他客户进程以后使用。</li>
</ol>
<hr>
<h1>2 用户数据报协议 UDP</h1>
<h2 id="2-1-udp-概述">2.1 UDP 概述</h2>
<p>UDP 只在 IP 的数据报服务之上增加了很少一点的功能，即</p>
<ol>
<li>端口的功能</li>
<li>差错检测的功能</li>
</ol>
<p>虽然 UDP 用户数据报只能提供不可靠的交付，但 UDP 在某些方面有其特殊的优点。</p>
<h3 id="2-1-1-udp-的主要特点">2.1.1 UDP 的主要特点 </h3>
<ol>
<li>
<p>UDP 是无连接的，即发送数据之前不需要建立连接，减少了开销。</p>
</li>
<li>
<p>UDP 使用尽最大努力交付，即不保证可靠交付，同时也不使用拥塞控制。</p>
</li>
<li>
<p>UDP 是面向报文的。</p>
<p>发送方 UDP 对应用程序交下来的报文，在添加首部后就向下交付 IP 层。UDP 对应用层交下来的报文，既不合并，也不拆分，而是保留这些报文的边界。</p>
<p>应用层交给 UDP 多长的报文，UDP 就照样发送，即一次发送一个报文。</p>
<p>接收方 UDP 对 IP 层交上来的 UDP 用户数据报，在去除首部后就原封不动地交付上层的应用进程，一次交付一个完整的报文。</p>
<p>应用程序必须选择合适大小的报文。</p>
</li>
<li>
<p>UDP 没有拥塞控制，很适合多媒体通信的要求。 </p>
</li>
<li>
<p>UDP 支持一对一、一对多、多对一和多对多的交互通信。</p>
</li>
<li>
<p>UDP 的首部开销小，只有 8 个字节。，比TCP的20字节要短。</p>
</li>
</ol>
<p><img src="image_yHtF5AV3OY.png" alt=""></p>
<h2 id="2-2-udp-的首部格式">2.2 UDP 的首部格式</h2>
<p><img src="image_tV8IDhobYn.png" alt=""></p>
<p>用户数据报 UDP 有两个字段：数据字段和首部字段。</p>
<p>首部字段有 8 个字节，由 4 个字段组成，每个字段都是两个字节。 </p>
<h3 id="2-2-1-计算-udp-检验和">2.2.1 计算 UDP 检验和</h3>
<p>在计算检验和时，临时把“伪首部”和 UDP 用户数据报连接在一起。伪首部仅仅是为了计算检验和。</p>
<p>UDP把首部和数据一起都校验，若UDP用户数据报不是偶数个字节，则要填入一个全0字节（此字节不发送）。然后按照二进制反码计算出这些16位字的和。</p>
<p><img src="image_jt4jhSh512.png" alt=""></p>
<p>不难看出，这种简单的差错检验方法的检错能力并不强，但它的好处是简单，处理起来较快。</p>
<hr>
<h1>3 传输控制协议 TCP</h1>
<h2 id="3-1-tcp-最主要的特点">3.1 TCP 最主要的特点</h2>
<ol>
<li>TCP 是<strong>面向连接</strong>的运输层协议，在通信之间要先建立连接，通信之后要释放连接。</li>
<li>每一条 TCP 连接只能有<strong>两个端点</strong>(endpoint)，每一条 TCP 连接只能是点对点的（一对一）。 </li>
<li><strong>TCP 提供可靠交付的服务</strong>。通过TCP连接传送的数据，无差错、不丢失、不重复，并且按序到达。</li>
<li><strong>TCP 提供全双工通信</strong>。TCP允许通信双方的应用进程在任何时候都能发送数据，TCP连接的两端都设有发送缓存和接受缓存，用来临时存放双向通信的数据。</li>
<li><strong>面向字节流</strong>。TCP中的“流”指的是流入到进程或从进程流出的字节序列。TCP把应用进程交下来的数据仅仅看成一连串的无结构的字节流，TCP并不知道所传送的字节流的含义。</li>
</ol>
<p><img src="image_Ayg_aFsyZ-.png" alt=""></p>
<p>TCP 连接是一条虚连接而不是一条真正的物理连接。</p>
<p>TCP 对应用进程一次把多长的报文发送到TCP 的缓存中是不关心的。TCP 根据对方给出的窗口值和当前网络拥塞的程度来决定一个报文段应包含多少个字节（UDP 发送的报文长度是应用进程给出的）。</p>
<p>TCP 可把太长的数据块划分短一些再传送。TCP 也可等待积累有足够多的字节后再构成报文段发送出去。 </p>
<h2 id="3-2-tcp-的连接">3.2 TCP 的连接</h2>
<p>TCP 把连接作为最基本的抽象。每一条 TCP 连接有两个端点。</p>
<p>TCP 连接的端点不是主机，不是主机的IP 地址，不是应用进程，也不是运输层的协议端口。TCP 连接的端点叫做<strong>套接字(socket)<strong>或</strong>插口</strong>。</p>
<p>端口号拼接到(contatenated with) IP 地址即构成了套接字。   </p>
<p><img src="image_J5GivylAG2.png" alt=""></p>
<p>每一条 TCP 连接唯一地被通信两端的两个端点（即两个套接字）所确定。即：</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>T</mi><mi>C</mi><mi>P</mi><mtext>连接</mtext><mo>:</mo><mo>:</mo><mo>=</mo><mrow><mi>s</mi><mi>o</mi><mi>c</mi><mi>k</mi><mi>e</mi><mi>t</mi><mn>1</mn><mo separator="true">,</mo><mi>s</mi><mi>o</mi><mi>c</mi><mi>k</mi><mi>e</mi><mi>t</mi><mn>2</mn></mrow><mo>=</mo><mrow><mo stretchy="false">(</mo><mi>I</mi><mi>P</mi><mn>1</mn><mo>:</mo><mi>p</mi><mi>o</mi><mi>r</mi><mi>t</mi><mn>1</mn><mo stretchy="false">)</mo><mo separator="true">,</mo><mo stretchy="false">(</mo><mi>I</mi><mi>P</mi><mn>2</mn><mo>:</mo><mi>p</mi><mi>o</mi><mi>r</mi><mi>t</mi><mn>2</mn><mo stretchy="false">)</mo></mrow></mrow><annotation encoding="application/x-tex">TCP 连接 ::= {socket1, socket2} 
             = {(IP1: port1), (IP2: port2)} 
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="mord cjk_fallback">连</span><span class="mord cjk_fallback">接</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mrel">:</span></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault">s</span><span class="mord mathdefault">o</span><span class="mord mathdefault">c</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mord mathdefault">e</span><span class="mord mathdefault">t</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">o</span><span class="mord mathdefault">c</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mord mathdefault">e</span><span class="mord mathdefault">t</span><span class="mord">2</span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.07847em;">I</span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord mathdefault">p</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">t</span><span class="mord">1</span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.07847em;">I</span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="mord">2</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord mathdefault">p</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">t</span><span class="mord">2</span><span class="mclose">)</span></span></span></span></span></span></p>
<p>同一个IP地址可以有多个不同的TCP连接，而同一个端口号也可以出现在多个不同的TCP连接中。</p>
<h3 id="3-2-1-同一个名词-socket有多种不同的意思">3.2.1 同一个名词 socket有多种不同的意思</h3>
<ol>
<li>
<p>应用编程接口 API 称为 socket API, 简称为 socket。</p>
</li>
<li>
<p>socket API 中使用的一个函数名也叫作 socket。</p>
</li>
<li>
<p>调用 socket 函数的端点称为 socket。</p>
</li>
<li>
<p>调用 socket 函数时其返回值称为 socket 描述符，可简称为 socket。</p>
</li>
<li>
<p>在操作系统内核中连网协议的 Berkeley 实现，称为 socket 实现。    </p>
</li>
</ol>
<hr>
<h1>4 可靠传输的工作原理</h1>
<h2 id="4-1-停止等待协议">4.1 停止等待协议</h2>
<p>停止等待协议就是每发送完一个分组就停止发送，等待对方的确认。在收到确认后再发送下一个分组。</p>
<h3 id="4-1-1-无差错情况">4.1.1 无差错情况</h3>
<p><img src="image_-rzvaGY3Rq.png" alt=""></p>
<p>A只要超过了一段时间仍然没有收到确认，就认为刚才发送的分组丢失了，因为重传前面发送过的分组，这就是<strong>超时重传</strong>。因此需要设置一个超时计时器。</p>
<ol>
<li>在发送完一个分组后，发送方必须暂时保留已发送的分组的副本。</li>
<li>分组和确认分组都必须进行编号。</li>
<li>超时计时器的重传时间应当比数据在分组传输的平均往返时间更长一些。 </li>
</ol>
<h3 id="4-1-2-确认丢失和确认迟到">4.1.2 确认丢失和确认迟到 </h3>
<p><img src="image_nwLTPk_bDe.png" alt=""></p>
<p>当B回复的确认M1丢失后，会收到重复的M1，这次应采取两个动作：</p>
<ol>
<li>丢弃这个重复的分组M1，不向上层重复交付</li>
<li>向A发送确认</li>
</ol>
<p>当A收到B回复的重复确认后，就收下进行丢弃，什么也不做。</p>
<p>使用上述的确认和重传机制，我们就可以在不可靠的传输网络上实现可靠的通信。</p>
<p>这种可靠传输协议常称为<strong>自动重传请求ARQ</strong> (Automatic Repeat reQuest)。ARQ 表明重传的请求是自动进行的。接收方不需要请求发送方重传某个出错的分组 。</p>
<h3 id="4-1-3-信道利用率">4.1.3 信道利用率</h3>
<p>停止等待协议的优点是简单，但缺点是信道利用率太低。 </p>
<p><img src="image_UGDGdo9jhz.png" alt=""></p>
<p>信道的利用率U计算如下：</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>U</mi><mo>=</mo><mfrac><msub><mi>T</mi><mi>D</mi></msub><mrow><msub><mi>T</mi><mi>D</mi></msub><mo>+</mo><mrow><mi mathvariant="normal">R</mi><mi mathvariant="normal">T</mi><mi mathvariant="normal">T</mi></mrow><mo>+</mo><msub><mi>T</mi><mi>A</mi></msub></mrow></mfrac></mrow><annotation encoding="application/x-tex">U=\frac{T_{D}}{T_{D}+\mathrm{RTT}+T_{A}}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">U</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.19633em;vertical-align:-0.8360000000000001em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.36033em;"><span style="top:-2.3139999999999996em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.02778em;">D</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord"><span class="mord mathrm">R</span><span class="mord mathrm">T</span><span class="mord mathrm">T</span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">A</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.02778em;">D</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.8360000000000001em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p>
<p>上式的往返时间RTT取决于所使用的信道。例如，假定1200km的信道的往返时间RTT=20ms，分组长度是1200bit，发送速率是1Mbit/s。若忽略处理时间和Ta（Ta一般都远小于Td），则可算出信道的利用率U=5.66%。</p>
<p>但若把发送速率提高到10Mbit/s，则<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>U</mi><mo>=</mo><mn>5.96</mn><mo>×</mo><mn>1</mn><msup><mn>0</mn><mrow><mo>−</mo><mn>3</mn></mrow></msup></mrow><annotation encoding="application/x-tex">U=5.96 ×10^{-3}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">U</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">5</span><span class="mord">.</span><span class="mord">9</span><span class="mord">6</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight">3</span></span></span></span></span></span></span></span></span></span></span></span>，信道在绝大多数时间内都是空闲的。</p>
<h3 id="4-1-4-流水线传输">4.1.4 流水线传输</h3>
<p>发送方可连续发送多个分组，不必每发完一个分组就停顿下来等待对方的确认。由于信道上一直有数据不间断地传送，这种传输方式可获得很高的信道利用率。 </p>
<p><img src="image_wWMDyfjlo0.png" alt=""></p>
<p>当使用流水线传输时，就要使用下面介绍的连续ARQ协议和滑动窗口协议。</p>
<h2 id="4-2-连续-arq-协议">4.2 连续 ARQ 协议</h2>
<p><img src="image_6cKyJTfVaI.png" alt=""></p>
<p>位于发送窗口内的5个分组都可以连续发送出去，而不需要等待对方的确认。</p>
<p>连续ARQ协议规定，发送方每收到一个确认，就把发送窗口向前滑动一个分组的位置。</p>
<p>接收方一般采用累积确认的方式。即不必对收到的分组逐个发送确认，而是对按序到达的最后一个分组发送确认，这样就表示：到这个分组为止的所有分组都已正确收到了。</p>
<p>累积确认的优点：容易实现，即使确认丢失也不必重传。缺点是：不能向发送方反映出接收方已经正确收到的所有分组的信息。</p>
<h3 id="4-2-1-go-back-n-回退-n">4.2.1 Go-back-N（回退 N）</h3>
<p>如果发送方发送了前 5 个分组，而中间的第 3 个分组丢失了。这时接收方只能对前两个分组发出确认。发送方无法知道后面三个分组的下落，而只好把后面的三个分组都再重传一次。</p>
<p>这就叫做 <strong>Go-back-N</strong>（回退 N），表示需要再退回来重传已发送过的 N 个分组。<br>
可见当通信线路质量不好时，连续 ARQ 协议会带来负面的影响。 </p>
<hr>
<h1>5 TCP 报文段的首部格式</h1>
<p><img src="image_RTqbYt_RRx.png" alt=""></p>
<h2 id="5-1-首部各个字段的含义">5.1 首部各个字段的含义</h2>
<h3 id="5-1-1-源端口和目的端口">5.1.1 源端口和目的端口</h3>
<p>各占 2 字节。端口是运输层与应用层的服务接口。</p>
<p>运输层的复用和分用功能都要通过端口才能实现。  </p>
<h3 id="5-1-2-序号">5.1.2 序号</h3>
<p>占 4 字节。TCP 连接中传送的数据流中的每一个字节都编上一个序号。</p>
<p>序号字段的值则指的是本报文段所发送的数据的第一个字节的序号。 </p>
<h3 id="5-1-3-确认号">5.1.3 确认号</h3>
<p>占 4 字节，是期望收到对方的下一个报文段的数据的第一个字节的序号。</p>
<h3 id="5-1-4-数据偏移-即首部长度">5.1.4 数据偏移（即首部长度）</h3>
<p>占 4 位，它指出 TCP 报文段的数据起始处距离 TCP 报文段的起始处有多远。</p>
<p>“数据偏移”的单位是 32 位字（以 4 字节为计算单位）。</p>
<h3 id="5-1-5-保留">5.1.5 保留</h3>
<p>占 6 位，保留为今后使用，但目前应置为0。</p>
<h3 id="5-1-6-紧急-urg">5.1.6 紧急 URG </h3>
<p>当 URG = 1 时，表明紧急指针字段有效。它告诉系统此报文段中有紧急数据，应尽快传送(相当于高优先级的数据)。 </p>
<h3 id="5-1-7-确认-ack">5.1.7 确认 ACK</h3>
<ul>
<li>只有当 ACK = 1 时确认号字段才有效。</li>
<li>当 ACK = 0 时，确认号无效。</li>
</ul>
<p>TCP规定,在连接建立后所有传送的报文段都必须把ACK置为１。</p>
<h3 id="5-1-8-推送-psh">5.1.8 推送 PSH</h3>
<p>当两个应用进程进行交互式的通信时,有时在一端的应用进程希望在键入一个命令后立即能够收到对方的响应，可以使用push操作。</p>
<p>接收 TCP 收到 PSH = 1 的报文段，就尽快地交付接收应用进程，而不再等到整个缓存都填满了后再向上交付。  </p>
<p>虽然应用进程可以选择推送操作，但推送操作很少使用。</p>
<h3 id="5-1-9-复位-rst">5.1.9 复位 RST</h3>
<p>当 RST = 1 时，表明 TCP 连接中出现严重差错（如由于主机崩溃或其他原因），必须释放连接，然后再重新建立运输连接。</p>
<p>RST = 1还用来拒绝一个非法的报文段或拒绝打开一个连接，RST也可称为重建位或重置位。</p>
<h3 id="5-1-10-同步-syn">5.1.10 同步 SYN</h3>
<p>同步 SYN = 1 表示这是一个连接请求或连接接受报文。对方若同意建立连接，则应在响应的报文段中使用SYN = 1和ACK = 1。</p>
<h3 id="5-1-11-终止-fin">5.1.11 终止 FIN</h3>
<p>用来释放一个连接。FIN = 1 表明此报文段的发送端的数据已发送完毕，并要求释放运输连接。</p>
<h3 id="5-1-12-窗口字段">5.1.12 窗口字段</h3>
<p>占 2 字节，用来让对方设置发送窗口的依据，单位为字节。</p>
<p>窗口值告诉对方：本报文段首部中的确认号算起，接收方目前允许对方发送的数据量（以字节为单位）。</p>
<h3 id="5-1-13-检验和">5.1.13 检验和</h3>
<p>占 2 字节。检验和字段检验的范围包括首部和数据这两部分。在计算检验和时，要在 TCP 报文段的前面加上 12 字节的伪首部。</p>
<p>但把伪首部第4个字段中的17改为6（TCP的协议号为6）。</p>
<h3 id="5-1-14-紧急指针">5.1.14 紧急指针</h3>
<p>占 16 位，指出在本报文段中紧急数据共有多少个字节（紧急数据放在本报文段数据的最前面）。</p>
<h3 id="5-1-15-选项">5.1.15 选项</h3>
<p>长度可变。TCP 最初只规定了一种选项，即最大报文段长度 MSS。MSS 告诉对方 TCP：“我的缓存所能接收的报文段的<strong>数据字段</strong>的最大长度是 MSS 个字节。” </p>
<h3 id="5-1-16-其他选项">5.1.16 其他选项</h3>
<ul>
<li>
<p>窗口扩大选项 ——占 3 字节，其中有一个字节表示移位值 S。新的窗口值等于TCP 首部中的窗口位数增大到(16 + S)，相当于把窗口值向左移动 S 位后获得实际的窗口大小。</p>
</li>
<li>
<p>时间戳选项——占10 字节，其中最主要的字段时间戳值字段（4 字节）和时间戳回送回答字段（4 字节）。</p>
</li>
<li>
<p>选择确认选项——在后面的 5.6.3 节介绍。 </p>
</li>
</ul>
<p>时间戳选项有以下两个功能：</p>
<ol>
<li>用来计算往返时间RTT</li>
<li>用于处理TCP序号超过<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>32</mn></msup></mrow><annotation encoding="application/x-tex">2^{32}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">3</span><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span></span>的情况，<strong>防止序号绕回</strong>PAWS。</li>
</ol>
<hr>
<h1>6 TCP 可靠传输的实现</h1>
<h2 id="6-1-以字节为单位的滑动窗口">6.1 以字节为单位的滑动窗口</h2>
<p><img src="image_nzUxWfT5Fg.png" alt=""></p>
<p><img src="image_sqPvTZI9ss.png" alt=""></p>
<p><img src="image_BEkdaJK56K.png" alt=""></p>
<p><img src="image_IjbxyU7fuI.png" alt=""></p>
<h3 id="6-1-1-发送缓存">6.1.1 发送缓存</h3>
<p><img src="image_yvGWIguA6H.png" alt=""></p>
<p>发送缓存用来存放：</p>
<ol>
<li>发送应用进程传送给发送方TCP准备发送的数据</li>
<li>TCP已发送但尚未收到确认的数据</li>
</ol>
<h3 id="6-1-2-接收缓存">6.1.2 接收缓存</h3>
<p><img src="image_LNIsvM8rwy.png" alt=""></p>
<p>接收缓存用来暂时存放：</p>
<ol>
<li>按序到达的、但尚未被接收应用程序读取的数据</li>
<li>不按序到达的数据</li>
</ol>
<p>需要强调三点</p>
<ol>
<li>
<p>A 的发送窗口并不总是和 B 的接收窗口一样大（因为有一定的时间滞后）。</p>
</li>
<li>
<p>TCP 标准没有规定对不按序到达的数据应如何处理。通常是先临时存放在接收窗口中，等到字节流中所缺少的字节收到后，再按序交付上层的应用进程。</p>
</li>
<li>
<p>TCP 要求接收方必须有<strong>累积确认</strong>的功能，这样可以减小传输开销。  </p>
</li>
</ol>
<p>TCP的通信是全双工通信，通信中的每一方都在发送和接受数据，因此每一方都有自己的发送窗口和接受窗口。</p>
<h2 id="6-2-超时重传时间的选择">6.2 超时重传时间的选择</h2>
<p>重传机制是 TCP 中最重要和最复杂的问题之一。</p>
<p>TCP 每发送一个报文段，就对这个报文段设置一次计时器。只要计时器设置的重传时间到但还没有收到确认，就要重传这一报文段。</p>
<p>由于 TCP 的下层是一个互联网环境，IP 数据报所选择的路由变化很大。因而运输层的往返时间的方差也很大。</p>
<p><img src="image_-KV1kWkATr.png" alt=""></p>
<p>TCP采用了一种自适应算法，它记录一个报文段发出的时间，以及收到响应的确认的时间，这两个时间之差就是报文段的往返时间RTT。</p>
<h3 id="6-2-1-加权平均往返时间-rtts">6.2.1 加权平均往返时间 RTTS</h3>
<p>TCP 保留了 RTT 的一个加权平均往返时间 RTTS（又称为平滑往返时间）。</p>
<p>第一次测量到 RTT 样本时，RTTS 值就取为所测量到的 RTT 样本值。以后每测量到一个新的 RTT 样本，就按下式重新计算一次 RTTS：</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>新</mtext><mi>R</mi><mi>T</mi><msub><mi>T</mi><mi mathvariant="bold">S</mi></msub><mo>=</mo><mo stretchy="false">(</mo><mn mathvariant="bold">1</mn><mo>−</mo><mi>α</mi><mo stretchy="false">)</mo><mo>×</mo><mo fence="true">(</mo><mtext>旧</mtext><mrow><msub><mrow><mi mathvariant="bold">R</mi><mi mathvariant="bold">T</mi><mi mathvariant="bold">T</mi></mrow><mi mathvariant="bold">S</mi></msub><mo fence="true">)</mo></mrow><mo>+</mo><mi>α</mi><mo>×</mo><mo stretchy="false">(</mo><mtext>新的</mtext><mi>R</mi><mi>T</mi><mi>T</mi><mtext>样本</mtext><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">新RTT_\mathbf{S}=(\mathbf{1}-\alpha) \times\left(\right. 旧 \left.\mathbf{R T T}_{\mathbf{S}}\right)+\alpha \times( 新的 RTT 样本 )
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord cjk_fallback">新</span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33027699999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathbf mtight">S</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathbf">1</span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.0037em;">α</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;">(</span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord cjk_fallback">旧</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner"><span class="mopen nulldelimiter"></span><span class="mord"><span class="mord"><span class="mord mathbf">R</span><span class="mord mathbf">T</span><span class="mord mathbf">T</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33027699999999993em;"><span style="top:-2.5500000000000003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathbf mtight">S</span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose delimcenter" style="top:0em;">)</span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault" style="margin-right:0.0037em;">α</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord cjk_fallback">新</span><span class="mord cjk_fallback">的</span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mord cjk_fallback">样</span><span class="mord cjk_fallback">本</span><span class="mclose">)</span></span></span></span></span></p>
<p>式中，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn><mo>≤</mo><mi>α</mi><mo>&lt;</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">0 \leq \alpha&lt;1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">0</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathdefault" style="margin-right:0.0037em;">α</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>。若 α 很接近于零，表示 RTT 值更新较慢。若选择 α 接近于 1，则表示 RTT 值更新较快。RFC 2988 推荐的 α 值为 1/8，即 0.125。</p>
<h3 id="6-2-2-超时重传时间rto">6.2.2 超时重传时间RTO</h3>
<p>显然RTO应该略大于上面得到的RTTs，RFC 2988 建议使用下式计算 RTO：</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mi>R</mi><mi>T</mi><mi>O</mi></mrow><mo>=</mo><mrow><mi>R</mi><mi>T</mi><mi>T</mi><mi>s</mi></mrow><mo>+</mo><mn>4</mn><mo>×</mo><msub><mrow><mi>R</mi><mi>T</mi><mi>T</mi></mrow><mi>D</mi></msub></mrow><annotation encoding="application/x-tex">{R T O}={R T T s}+4 \times {RTT}_{D}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.76666em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mord mathdefault">s</span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">4</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord"><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.02778em;">D</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span></p>
<ul>
<li>RTTD是RTT 的偏差的加权平均值。</li>
</ul>
<p>RFC 2988 建议这样计算 RTTD。第一次测量时，RTTD 值取为测量到的 RTT 样本值的一半。在以后的测量中，则使用下式计算加权平均的 RTTD：</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>新的</mtext><mi>R</mi><mi>T</mi><msub><mi>T</mi><mi>D</mi></msub><mo>=</mo><mo stretchy="false">(</mo><mn>1</mn><mo>−</mo><mi>β</mi><mo stretchy="false">)</mo><mo>×</mo><mo stretchy="false">(</mo><mtext>旧的</mtext><mi>R</mi><mi>T</mi><msub><mi>T</mi><mi>D</mi></msub><mo stretchy="false">)</mo><mo>+</mo><mi>β</mi><mo>×</mo><mo>∣</mo><msub><mi>R</mi><mi>S</mi></msub><mo>−</mo><mtext>新的</mtext><mi>R</mi><mi>T</mi><mi>T</mi><mtext>样本</mtext><mo>∣</mo></mrow><annotation encoding="application/x-tex">新的RTT_{D}=(1-\beta) \times(旧的RTT_{D})+\beta \times \mid R_{S}- 新的 RTT 样本 \mid
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord cjk_fallback">新</span><span class="mord cjk_fallback">的</span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.02778em;">D</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.05278em;">β</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord cjk_fallback">旧</span><span class="mord cjk_fallback">的</span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.02778em;">D</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.05278em;">β</span><span class="mord">×</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∣</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.00773em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.05764em;">S</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord cjk_fallback">新</span><span class="mord cjk_fallback">的</span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mord cjk_fallback">样</span><span class="mord cjk_fallback">本</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∣</span></span></span></span></span></p>
<ul>
<li>β 是个小于 1 的系数，其推荐值是 1/4，即 0.25。</li>
</ul>
<h3 id="6-2-3-karn-算法">6.2.3 Karn 算法</h3>
<p>TCP 报文段没有收到对应的确认，则重传，之后收到了确认报文段 ACK。</p>
<p>那么，问题是：该确认报文段 ACK报文段的确认，还是对其重传报文段的确认呢 ？ </p>
<p><img src="image_7zjfoNbGQv.png" alt=""></p>
<p>采用Karm算法，即在计算平均往返时间 RTT 时，只要报文段重传了，就不采用其往返时间样本。这样得出的加权平均平均往返时间 RTTS 和超时重传时间 RTO 就较准确。 </p>
<h3 id="6-2-4-修正的-karn-算法">6.2.4 修正的 Karn 算法</h3>
<p>但是如果报文段的时延突然增大了很多，如果报文段重传了而不采用其往返时间样本，无法更新超时重传时间。</p>
<p>报文段每重传一次，就把 RTO 增大一些：</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>新的</mtext><mi>R</mi><mi>T</mi><mi>O</mi><mo>=</mo><mi>γ</mi><mo>×</mo><mo stretchy="false">(</mo><mtext>旧的</mtext><mi>R</mi><mi>T</mi><mi>O</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">新的 RTO =\gamma \times (旧的 RTO)
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord cjk_fallback">新</span><span class="mord cjk_fallback">的</span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.7777700000000001em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05556em;">γ</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord cjk_fallback">旧</span><span class="mord cjk_fallback">的</span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mclose">)</span></span></span></span></span></p>
<ul>
<li>系数 γ 的典型值是 2 。</li>
</ul>
<p>当不再发生报文段的重传时，才根据报文段的RTT更新RTTS 和RTO 。实践证明，这种策略较为合理。 </p>
<h2 id="6-3-选择确认-sack">6.3 选择确认 SACK</h2>
<p>接收方收到了和前面的字节流不连续的两个字节块。</p>
<p>如果这些字节的序号都在接收窗口之内，那么接收方就先收下这些数据，但要把这些信息准确地告诉发送方，使发送方不要再重复发送这些已收到的数据。 </p>
<p><img src="image_OIAGvUvEzw.png" alt=""></p>
<p>和前后字节不连续的每一个字节块都有两个边界：左边界和右边界。图中用四个指针标记这些边界。</p>
<ol>
<li>
<p>第一个字节块的左边界 L1 = 1501，但右边界 R1 = 3001。</p>
<p>左边界指出字节块的第一个字节的序号，但右边界减 1 才是字节块中的最后一个序号。</p>
</li>
<li>
<p>第二个字节块的左边界 L2 = 3501，而右边界 R2 = 4501。 </p>
</li>
</ol>
<p>如果要使用选择确认，那么在建立 TCP 连接时，就要在 TCP 首部的选项中加上“允许 SACK”的选项，而双方必须都事先商定好。</p>
<p>如果使用选择确认，那么原来首部中的“确认号字段”的用法仍然不变。只是以后在 TCP 报文段的首部中都增加了 SACK 选项，以便报告收到的不连续的字节块的边界。</p>
<p>由于首部选项的长度最多只有 40 字节，而指明一个边界就要用掉 4 字节，因此在选项中最多只能指明 4 个字节块的边界信息。</p>
<hr>
<h1>7 TCP 的流量控制</h1>
<h2 id="7-1-利用滑动窗口实现流量控制">7.1 利用滑动窗口实现流量控制</h2>
<p>一般说来，我们总是希望数据传输得更快一些。但如果发送方把数据发送得过快，接收方就可能来不及接收，这就会造成数据的丢失。</p>
<p>流量控制（flow control）就是让发送方的发送速率不要太快，既要让接收方来得及接收，也不要使网络发生拥塞。</p>
<p>利用滑动窗口机制可以很方便地在 TCP 连接上实现流量控制。 </p>
<h3 id="7-1-1-流量控制举例">7.1.1 流量控制举例</h3>
<p>A 向 B 发送数据。</p>
<p>在连接建立时，B 告诉 A：“我的接收窗口 rwnd = 400（字节）”。</p>
<p><img src="image_KYyIbIX9BY.png" alt=""></p>
<hr>
<h1>8 TCP的拥塞控制</h1>
<h2 id="8-1-拥塞控制的一般原理">8.1 拥塞控制的一般原理</h2>
<p>在某段时间，若对网络中某资源的需求超过了该资源所能提供的可用部分，网络的性能就要变坏——产生拥塞(congestion)。</p>
<p>出现资源拥塞的条件：</p>
<blockquote>
<p>对资源需求的总和 &gt; 可用资源</p>
</blockquote>
<p>若网络中有许多资源同时产生拥塞，网络的性能就要明显变坏，整个网络的吞吐量将随输入负荷的增大而下降。  </p>
<p>拥塞控制是很难设计的，因为它是一个动态的（而不是静态的）问题。</p>
<p>当前网络正朝着高速化的方向发展，这很容易出现缓存不够大而造成分组的丢失。但分组的丢失是网络发生拥塞的征兆而不是原因。</p>
<p>在许多情况下，甚至正是拥塞控制本身成为引起网络性能恶化甚至发生死锁的原因。这点应特别引起重视。 </p>
<h3 id="8-1-1-开环和闭环控制">8.1.1 开环和闭环控制</h3>
<ul>
<li><strong>开环控制</strong>方法就是在设计网络时事先将有关发生拥塞的因素考虑周到，力求网络在工作时不产生拥塞。 </li>
<li><strong>闭环控制</strong>是基于反馈环路的概念。属于闭环控制的有以下几种措施：<br>
监测网络系统以便检测到拥塞在何时、何处发生。
<ul>
<li>将拥塞发生的信息传送到可采取行动的地方。</li>
<li>调整网络系统的运行以解决出现的问题。</li>
</ul>
</li>
</ul>
<h3 id="8-1-2-拥塞控制与流量控制的关系">8.1.2 拥塞控制与流量控制的关系</h3>
<p>拥塞控制所要做的都有一个前提，就是网络能够承受现有的网络负荷。</p>
<p>拥塞控制是一个全局性的过程，涉及到所有的主机、所有的路由器，以及与降低网络传输性能有关的所有因素。 </p>
<p>流量控制往往指在给定的发送端和接收端之间的点对点通信量的控制。 </p>
<p>流量控制所要做的就是抑制发送端发送数据的速率，以便使接收端来得及接收。 </p>
<h2 id="8-2-tcp的拥塞控制方法">8.2 TCP的拥塞控制方法</h2>
<p>TCP进行拥塞控制的算法有四种：慢开始、拥塞避免、快重传和快恢复。</p>
<h3 id="8-2-1-慢开始">8.2.1 慢开始</h3>
<p>发送方维持一个叫做拥塞窗口 cwnd（congestion window）的状态变量。拥塞窗口的大小取决于网络的拥塞程度，并且动态地在变化。发送方让自己的发送窗口等于拥塞窗口。如再考虑到接收方的接收能力，则发送窗口还可能小于拥塞窗口。</p>
<p><strong>发送方控制拥塞窗口的原则是</strong>：只要网络没有出现拥塞，拥塞窗口就再增大一些，以便把更多的分组发送出去。但只要网络出现拥塞，拥塞窗口就减小一些，以减少注入到网络中的分组数。 </p>
<h4 id="8-2-1-1-慢开始算法的原理">8.2.1.1 慢开始算法的原理</h4>
<ol>
<li>
<p>在主机刚刚开始发送报文段时可先设置拥塞窗口 cwnd = 1，即设置为一个最大报文段 MSS 的数值。</p>
</li>
<li>
<p>在每收到一个对新的报文段的确认后，将拥塞窗口加 1，即增加一个 MSS 的数值。</p>
</li>
<li>
<p>用这样的方法逐步增大发送端的拥塞窗口 cwnd，可以使分组注入到网络的速率更加合理。 </p>
</li>
</ol>
<p><img src="image_BqS15bXn_m.png" alt=""></p>
<h4 id="8-2-1-2-传输轮次">8.2.1.2 传输轮次</h4>
<p>使用慢开始算法后，每经过一个传输轮次，拥塞窗口 cwnd 就加倍。</p>
<p>一个传输轮次所经历的时间其实就是往返时间 RTT。</p>
<p><strong>“传输轮次”更加强调</strong>：把拥塞窗口 cwnd 所允许发送的报文段都连续发送出去，并收到了对已发送的最后一个字节的确认。</p>
<p>例如，拥塞窗口 cwnd = 4，这时的往返时间 RTT 就是发送方连续发送 4 个报文段，并收到这 4 个报文段的确认，总共经历的时间。 </p>
<p>由此可见，慢开始的“慢”并不是cwnd的增长速率慢，而是指在TCP开始发送报文段时，只发送一个报文段，即设置cwnd = 1，目的是试探一下网络的拥塞情况，然后视情况再逐渐增大cwnd。</p>
<h3 id="8-2-2-拥塞避免">8.2.2 拥塞避免</h3>
<p>为了防止拥塞窗口cwnd增长过大引起网络拥塞，还需要设置一个慢开始门限ssthresh状态变量，慢开始门限 ssthresh 的用法如下：</p>
<ol>
<li>
<p>当 cwnd &lt; ssthresh 时，使用慢开始算法。</p>
</li>
<li>
<p>当 cwnd &gt; ssthresh 时，停止使用慢开始算法而改用拥塞避免算法。</p>
</li>
<li>
<p>当 cwnd = ssthresh 时，既可使用慢开始算法，也可使用拥塞避免算法。</p>
</li>
</ol>
<p>拥塞避免算法的思路是让拥塞窗口 cwnd 缓慢地增大，即每经过一个往返时间 RTT 就把发送方的拥塞窗口 cwnd 加 1，而不是加倍，使拥塞窗口 cwnd 按线性规律缓慢增长。</p>
<p>无论在慢开始阶段还是在拥塞避免阶段，只要发送方判断网络出现拥塞（其根据就是没有按时收到确认），就要把慢开始门限 ssthresh 设置为出现拥塞时的<strong>发送方窗口值的一半</strong>（但不能小于2）。然后把拥塞窗口 cwnd 重新设置为 1，执行慢开始算法。</p>
<p>这样做的目的就是要迅速减少主机发送到网络中的分组数，使得发生拥塞的路由器有足够时间把队列中积压的分组处理完毕。 </p>
<h3 id="8-2-3-慢开始和拥塞避免算法的实现举例">8.2.3 慢开始和拥塞避免算法的实现举例</h3>
<p>当 TCP 连接进行初始化时，将拥塞窗口置为 1。下图中的窗口单位不使用字节而使用报文段。</p>
<p>慢开始门限的初始值设置为 16 个报文段，即 ssthresh = 16。</p>
<p>发送端的发送窗口不能超过拥塞窗口 cwnd 和接收端窗口 rwnd 中的最小值。我们假定接收端窗口足够大，因此现在发送窗口的数值等于拥塞窗口的数值。</p>
<p><img src="image_D315wWkKOI.png" alt=""></p>
<p>在执行慢开始算法时，拥塞窗口 cwnd 的初始值为 1，发送第一个报文段 M0。  </p>
<p>发送端每收到一个确认 ，就把 cwnd 加 1。于是发送端可以接着发送 M1 和 M2 两个报文段。 </p>
<p>接收端共发回两个确认。发送端每收到一个对新报文段的确认，就把发送端的 cwnd 加 1。现在 cwnd 从 2 增大到 4，并可接着发送后面的 4 个报文段。 </p>
<p>发送端每收到一个对新报文段的确认，就把发送端的拥塞窗口加 1，因此拥塞窗口 cwnd 随着传输轮次按指数规律增长。 </p>
<p>当拥塞窗口 cwnd 增长到慢开始门限值 ssthresh 时（即当 cwnd = 16 时），就改为执行拥塞避免算法，拥塞窗口按线性规律增长。 </p>
<p>假定拥塞窗口的数值增长到 24 时，网络出现超时，表明网络拥塞了。 </p>
<p>更新后的 ssthresh 值变为 12（即发送窗口数值 24 的一半），拥塞窗口再重新设置为 1，并执行慢开始算法。 </p>
<p>当 cwnd = 12 时改为执行拥塞避免算法，拥塞窗口按按线性规律增长，每经过一个往返时延就增加一个 MSS 的大小。</p>
<h4 id="8-2-3-1-乘法减小">8.2.3.1 乘法减小</h4>
<p>“乘法减小“是指不论在慢开始阶段还是拥塞避免阶段，只要出现一次超时（即出现一次网络拥塞），就把慢开始门限值 ssthresh 设置为当前的拥塞窗口值乘以 0.5。</p>
<p>当网络频繁出现拥塞时，ssthresh 值就下降得很快，以大大减少注入到网络中的分组数。 </p>
<h4 id="8-2-3-2-加法增大">8.2.3.2 加法增大</h4>
<p>“加法增大”是指执行拥塞避免算法后，在收到对所有报文段的确认后（即经过一个往返时间），就把拥塞窗口 cwnd增加一个 MSS 大小，使拥塞窗口缓慢增大，以防止网络过早出现拥塞。 </p>
<p>加法增大和乘法减小合在一起称为<code>AIMD</code>算法。</p>
<h3 id="8-2-4-快重传">8.2.4 快重传</h3>
<p>快重传算法首先要求接收方每收到一个失序的报文段后就立即发出重复确认。这样做可以让发送方及早知道有报文段没有到达接收方。 </p>
<p>发送方只要一连收到三个重复确认就应当立即重传对方尚未收到的报文段。 </p>
<p>不难看出，快重传并非取消重传计时器，而是在某些情况下可更早地重传丢失的报文段。 </p>
<p><img src="image_etjH2VOgvP.png" alt=""></p>
<h3 id="8-2-5-快恢复">8.2.5 快恢复</h3>
<ol>
<li>
<p>当发送端收到连续三个重复的确认时，就执行“乘法减小”算法，把慢开始门限 ssthresh 减半。但接下去不执行慢开始算法。 </p>
</li>
<li>
<p>由于发送方现在认为网络很可能没有发生拥塞，因此现在不执行慢开始算法，即拥塞窗口 cwnd 现在不设置为 1，而是设置为慢开始门限 ssthresh 减半后的数值，然后开始执行拥塞避免算法（“加法增大”），使拥塞窗口缓慢地线性增大。 </p>
</li>
</ol>
<p><img src="image_2MKe-jj2gZ.png" alt=""></p>
<h3 id="8-2-6-发送窗口的上限值">8.2.6 发送窗口的上限值</h3>
<p>发送方的发送窗口的上限值应当取为接收方窗口 Rwnd 和拥塞窗口 Cwnd 这两个变量中较小的一个，即应按以下公式确定：</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi><mi>w</mi><mi>n</mi><mi>d</mi><mo>=</mo><mi>min</mi><mo>⁡</mo><mo stretchy="false">(</mo><mi>R</mi><mi>w</mi><mi>n</mi><mi>d</mi><mo separator="true">,</mo><mi>C</mi><mi>w</mi><mi>n</mi><mi>d</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">Swnd = \min(Rwnd, Cwnd)
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mord mathdefault">n</span><span class="mord mathdefault">d</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mop">min</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mord mathdefault">n</span><span class="mord mathdefault">d</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mord mathdefault">n</span><span class="mord mathdefault">d</span><span class="mclose">)</span></span></span></span></span></p>
<ul>
<li>
<p>当 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi><mi>w</mi><mi>n</mi><mi>d</mi><mo>&lt;</mo><mi>C</mi><mi>w</mi><mi>n</mi><mi>d</mi></mrow><annotation encoding="application/x-tex">Rwnd &lt; Cwnd</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.73354em;vertical-align:-0.0391em;"></span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mord mathdefault">n</span><span class="mord mathdefault">d</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mord mathdefault">n</span><span class="mord mathdefault">d</span></span></span></span> 时，是接收方的接收能力限制发送窗口的最大值。</p>
</li>
<li>
<p>当 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi><mi>w</mi><mi>n</mi><mi>d</mi><mo>&gt;</mo><mi>C</mi><mi>w</mi><mi>n</mi><mi>d</mi></mrow><annotation encoding="application/x-tex">Rwnd &gt; Cwnd</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.73354em;vertical-align:-0.0391em;"></span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mord mathdefault">n</span><span class="mord mathdefault">d</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mord mathdefault">n</span><span class="mord mathdefault">d</span></span></span></span> 时，则是网络的拥塞限制发送窗口的最大值。 </p>
</li>
</ul>
<h2 id="8-3-主动队列管理aqm">8.3 主动队列管理AQM</h2>
<p>TCP拥塞控制和网络层采取的策略有密切联系。</p>
<p>重传会使TCP连接的发送端认为在网络中发生了拥塞。于是在TCP的发送端就采取了拥塞控制措施， 但实际上网络并没有发生拥塞。 网络层的策略对TCP拥塞控制影响最大的就是路由器的<strong>分组丢弃策略</strong>。</p>
<h3 id="8-3-1-先进先出-fifo处理规则">8.3.1 “先进先出”FIFO处理规则</h3>
<p>路由器的队列通常都是按照“先进先出”FIFO (First In First Out) 的规则处理到来的分组。</p>
<p>当队列已满时，以后再到达的所有分组（如果能够继续排队，这些分组都将排在队列的尾部）将都被丢弃。这就叫做尾部丢弃策略 (tail-drop policy)。</p>
<p>路由器的尾部丢弃往往会导致一连串分组的丢失， 这就使发送方出现超时重传，使TCP进入拥塞控制的慢开始状态，结果使TCP连接的发送方突然把数据的发送速率降低到很小的数值。</p>
<p>更为严重的是，在网络中通常有很多的TCP连接， 这些连接中的报文段通常是复用在网络层的IP数据报中传送的。</p>
<p>在这种情况下，若发生了路由器中的尾部丢弃，就可能会同时影响到很多条TCP连接，结果使这许多TCP连接在同一时间突然都进入到慢开始状态。这在TCP 的术语中称为<strong>全局同步</strong> (global syncronization)。</p>
<p>全局同步使得全网的通信量突然下降了很多，而在网络恢复正常后，其通信量又突然增大很多。</p>
<h3 id="8-3-2-主动队列管理aqm">8.3.2 主动队列管理AQM</h3>
<p>1998年提出了主动队列管理AQM (Active Queue Management)。</p>
<p>所谓“主动”就是不要等到路由器的队列长度已经达到最大值时才不得不丢弃后面到达的分组。这样就太被动了。应当在队列长度达到某个值得警惕的数值时（即当网络拥塞有了某些拥塞征兆时），就主动丢弃到达的分组。</p>
<p>提醒发送方放慢发送速率，会有可能减轻网络拥塞甚至不出现拥塞。</p>
<p>AQM 可以有不同实现方法，其中曾流行多年的就是随机早期检测RED（Random Early Detection）。</p>
<h3 id="8-3-3-随机早期检测red">8.3.3 随机早期检测RED</h3>
<p>使路由器的队列维持两个参数：队列长度最小门限THmin和最大门限Thmax 。 RED对每一个到达的分组量，都先计算当前平均队列长度LAV 。</p>
<ol>
<li>若平均队列长度小于最小门限THmin，则将新到达的分组放入队列进行排队。</li>
<li>若平均队列长度超过最大门限THmax，则将新到达的分组丢弃。</li>
<li>若平均队列长度在最小门限THmin和最大门限THmax 之间，则按照某一概率p将新到达的分组丢弃。</li>
</ol>
<p><img src="image_1Xcn2EUiwd.png" alt=""></p>
<p>多年的实践证明，RED的使用效果并不太理想。 2015年公布的RFC 7567已经把RFC 2309列为陈旧的， 并且不再推荐使用RED。</p>
<p>对路由器进行主动队列管理AQM仍是必要的。 AQM实际上就是对路由器中的分组排队进行智能管理，而不是简单地把队列的尾部丢弃。 现在已经有几种不同的算法来代替旧的RED，但都还在实验阶段。</p>
<hr>
<h1>9 TCP的传输连接管理</h1>
<p>传输连接就有三个阶段，即：连接建立、数据传送和连接释放。传输连接的管理就是使传输连接的建立能正常地进行。</p>
<p>传输建立过程中要解决以下三个问题：</p>
<ol>
<li>
<p>要使每一方能够确知对方的存在。</p>
</li>
<li>
<p>要允许双方协商一些参数（如最大报文段长度，最大窗口大小，服务质量等）。</p>
</li>
<li>
<p>能够对传输实体资源（如缓存大小，连接表中的项目等）进行分配。  </p>
</li>
</ol>
<h2 id="9-1-tcp-连接的建立">9.1 TCP 连接的建立</h2>
<p>用三次握手建立 TCP 连接：</p>
<p><img src="image_PuWXflAhj9.png" alt=""></p>
<p>A 的 TCP 向 B TCP发出连接请求报文段，其首部中的同步位 SYN = 1，并选择序号 seq = x，表明传送数据时的第一个数据字节的序号是 x。</p>
<p><img src="image_oWAT5IphCu.png" alt=""></p>
<p>B 的 TCP 收到连接请求报文段后，如同意，则发回确认。</p>
<p>B 在确认报文段中应使 SYN = 1，使 ACK = 1，其确认号ack = x + 1，自己选择的序号 seq = y。</p>
<p><img src="image_7zCKAYl848.png" alt=""></p>
<p>A 收到此报文段后向 B 给出确认，其 ACK = 1，确认号 ack = y + 1。</p>
<p>A 的 TCP 通知上层应用进程，连接已经建立。   </p>
<p><img src="image_6CfvaQEYsM.png" alt=""></p>
<p> B 的 TCP 收到主机 A 的确认后，也通知其上层应用进程：TCP 连接已经建立。</p>
<p>用三次握手建立 TCP 连接的各状态：</p>
<p><img src="image_4y3XQ2HMNx.png" alt=""></p>
<p>上述B发送给A的报文段也可以拆分成两个报文段，可以先发送一个确认报文段（ACK＝１，ack=x+1），然后再发送一个同步报文段（SYN=1，seq=y），这样就变成了四报文握手。</p>
<h2 id="9-2-tcp-的连接释放">9.2 TCP 的连接释放</h2>
<p><img src="image_jYGFNDenkV.png" alt=""></p>
<p>数据传输结束后，通信的双方都可释放连接。现在 A 的应用进程先向其 TCP 发出连接释放报文段，并停止再发送数据，主动关闭 TCP 连接。</p>
<p>A 把连接释放报文段首部的 FIN = 1，其序号 seq = u，等待 B 的确认。</p>
<p><img src="image__KQ5zj73h9.png" alt=""></p>
<p>B 发出确认，确认号 ack = u + 1，而这个报文段自己的序号seq = v。TCP 服务器进程通知高层应用进程。</p>
<p>从 A 到 B 这个方向的连接就释放了，TCP 连接处于半关闭状态。B 若发送数据，A 仍要接收。</p>
<blockquote>
<p>一个方向的连接是什么意思？发送窗口没了？</p>
</blockquote>
<p><img src="image_uwagaidnwr.png" alt=""></p>
<p>若 B 已经没有要向 A 发送的数据，其应用进程就通知 TCP 释放连接。 </p>
<p><img src="image_Sdh3Mrz-Ih.png" alt=""></p>
<p>A 收到连接释放报文段后，必须发出确认。 </p>
<p>在确认报文段中 ACK = 1，确认号 ack = w + 1，自己的序号 seq = u + 1。 </p>
<p><img src="image_fgqRLXBtCI.png" alt=""></p>
<p>TCP 连接必须经过时间 2MSL 后才真正释放掉。 </p>
<ol>
<li>
<p>为了保证 A 发送的最后一个 ACK 报文段能够到达 B。</p>
</li>
<li>
<p>防止 “已失效的连接请求报文段”出现在本连接中。A 在发送完最后一个 ACK 报文段后，再经过时间 2MSL，就可以使本连接持续的时间内所产生的所有报文段，都从网络中消失。这样就可以使下一个新的连接中不会出现这种旧的连接请求报文段。</p>
</li>
</ol>
<p>除了时间等待计时器外，TCP还设有一个<strong>保活计时器</strong>，防止另一方突然下线。</p>
<h2 id="9-3-tcp-的有限状态机">9.3 TCP 的有限状态机</h2>
<p>TCP 有限状态机的图中每一个方框都是 TCP 可能具有的状态。</p>
<p>每个方框中的大写英文字符串是 TCP 标准所使用的 TCP 连接状态名。状态之间的箭头表示可能发生的状态变迁。</p>
<p>箭头旁边的字，表明引起这种变迁的原因，或表明发生状态变迁后又出现什么动作。</p>
<p>图中有三种不同的箭头。</p>
<ol>
<li>
<p>粗实线箭头表示对客户进程的正常变迁。</p>
</li>
<li>
<p>粗虚线箭头表示对服务器进程的正常变迁。</p>
</li>
<li>
<p>另一种细线箭头表示异常变迁。 </p>
</li>
</ol>
<p><img src="image_Q6kvt1QG4m.png" alt=""></p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="http://zhouzimu.top">弘树</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="http://zhouzimu.top/2024/06/09/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC5%E7%AB%A0%EF%BC%9A%E4%BC%A0%E8%BE%93%E5%B1%82/">http://zhouzimu.top/2024/06/09/计算机网络第5章：传输层/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://zhouzimu.top" target="_blank">诺亚方舟</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">计算机网络</a></div><div class="post_share"><div class="social-share" data-image="https://pic1.zhimg.com/v2-2159a954d03d90c2d869bf962a7ef775_720w.jpg?source=172ae18b" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i>码字不易，如果对你有帮助的话请喝一杯奶茶吧~</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/img/wechat.png" target="_blank"><img class="post-qr-code-img" src="/img/wechat.png" alt="微信"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="/img/alipay.png" target="_blank"><img class="post-qr-code-img" src="/img/alipay.png" alt="支付宝"/></a><div class="post-qr-code-desc">支付宝</div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2024/06/09/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC6%E7%AB%A0%EF%BC%9A%E5%BA%94%E7%94%A8%E5%B1%82/" title="计算机网络第6章：应用层"><img class="cover" src="https://www.scensmart.com/wp-content/uploads/2019/04/ARM-%E9%9B%86%E7%BE%A4%E6%9C%8D%E5%8A%A1%E5%99%A8-1-1024x576.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">计算机网络第6章：应用层</div></div></a></div><div class="next-post pull-right"><a href="/2024/06/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC4%E7%AB%A0%EF%BC%9A%E7%BD%91%E7%BB%9C%E5%B1%82/" title="计算机网络第4章：网络层"><img class="cover" src="https://so1.360tres.com/t01b34c003ce53dbb04.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">计算机网络第4章：网络层</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2024/06/09/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC2%E7%AB%A0%EF%BC%9A%E7%89%A9%E7%90%86%E5%B1%82/" title="计算机网络第2章：物理层"><img class="cover" src="https://th.bing.com/th/id/OIP.upyRHF4n063vA2_j7PdDhwHaC7?w=1440&h=571&rs=1&pid=ImgDetMain" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-06-09</div><div class="title">计算机网络第2章：物理层</div></div></a></div><div><a href="/2024/06/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC3%E7%AB%A0%EF%BC%9A%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/" title="计算机网络第3章：数据链路层"><img class="cover" src="https://pic2.zhimg.com/v2-15bdc5c257f7c109f184f9872c57b2d5_b.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-06-07</div><div class="title">计算机网络第3章：数据链路层</div></div></a></div><div><a href="/2024/06/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC4%E7%AB%A0%EF%BC%9A%E7%BD%91%E7%BB%9C%E5%B1%82/" title="计算机网络第4章：网络层"><img class="cover" src="https://so1.360tres.com/t01b34c003ce53dbb04.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-06-08</div><div class="title">计算机网络第4章：网络层</div></div></a></div><div><a href="/2024/06/09/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC6%E7%AB%A0%EF%BC%9A%E5%BA%94%E7%94%A8%E5%B1%82/" title="计算机网络第6章：应用层"><img class="cover" src="https://www.scensmart.com/wp-content/uploads/2019/04/ARM-%E9%9B%86%E7%BE%A4%E6%9C%8D%E5%8A%A1%E5%99%A8-1-1024x576.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-06-09</div><div class="title">计算机网络第6章：应用层</div></div></a></div><div><a href="/2024/06/22/%E8%AE%A1%E7%BD%91%E8%AF%BE%E8%AE%BE%EF%BC%9A%E5%9F%BA%E4%BA%8ETCP%E5%8D%8F%E8%AE%AE%E7%9A%84%E7%AE%80%E5%8E%86%E8%81%8A%E5%A4%A9%E5%AE%A4%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/" title="计网课设：基于TCP协议的简历聊天室程序设计"><img class="cover" src="https://haowallpaper.com/link/common/file/previewFileImg/6676074414d4ad203e7090e119edfda2" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-06-22</div><div class="title">计网课设：基于TCP协议的简历聊天室程序设计</div></div></a></div></div></div><hr class="custom-hr"/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="utterances-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/pic_editor_1635545191.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">弘树</div><div class="author-info__description">在我坚定无比的内心，总以最坚强的节奏解开案情</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">122</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">45</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">17</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/NoyeArk"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/NoyeArk" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="mailto:horiki0@qq.com" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #4a7dbe;"></i></a><a class="social-icon" href="https://leetcode.cn/u/horiki/" target="_blank" title="Leetcode"><i class="fas fa-l" style="color: #59e285;"></i></a><a class="social-icon" href="https://www.kaggle.com/horiki" target="_blank" title="Kaggle"><i class="fas fa-k" style="color: #4a7dbe;"></i></a></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc" style="font-size: 15px;"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-text">1 传输层协议概述</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-1-%E8%BF%9B%E7%A8%8B%E4%B9%8B%E9%97%B4%E7%9A%84%E9%80%9A%E4%BF%A1"><span class="toc-text">1.1 进程之间的通信</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-1-%E5%BA%94%E7%94%A8%E8%BF%9B%E7%A8%8B%E4%B9%8B%E9%97%B4%E7%9A%84%E9%80%9A%E4%BF%A1"><span class="toc-text">1.1.1 应用进程之间的通信</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-2-%E8%BF%90%E8%BE%93%E5%B1%82%E7%9A%84%E4%B8%BB%E8%A6%81%E5%8A%9F%E8%83%BD"><span class="toc-text">1.1.2 运输层的主要功能</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-2-%E8%BF%90%E8%BE%93%E5%B1%82%E7%9A%84%E4%B8%A4%E4%B8%AA%E4%B8%BB%E8%A6%81%E5%8D%8F%E8%AE%AE"><span class="toc-text">1.2 运输层的两个主要协议</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-3-%E8%BF%90%E8%BE%93%E5%B1%82%E7%9A%84%E7%AB%AF%E5%8F%A3"><span class="toc-text">1.3 运输层的端口</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3-1-%E7%AB%AF%E5%8F%A3%E5%8F%B7"><span class="toc-text">1.3.1 端口号</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3-2-%E8%BD%AF%E4%BB%B6%E7%AB%AF%E5%8F%A3%E4%B8%8E%E7%A1%AC%E4%BB%B6%E7%AB%AF%E5%8F%A3"><span class="toc-text">1.3.2 软件端口与硬件端口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3-3-%E4%B8%89%E7%B1%BB%E7%AB%AF%E5%8F%A3"><span class="toc-text">1.3.3 三类端口</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-text">2 用户数据报协议 UDP</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#2-1-udp-%E6%A6%82%E8%BF%B0"><span class="toc-text">2.1 UDP 概述</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-1-udp-%E7%9A%84%E4%B8%BB%E8%A6%81%E7%89%B9%E7%82%B9"><span class="toc-text">2.1.1 UDP 的主要特点 </span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-2-udp-%E7%9A%84%E9%A6%96%E9%83%A8%E6%A0%BC%E5%BC%8F"><span class="toc-text">2.2 UDP 的首部格式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-1-%E8%AE%A1%E7%AE%97-udp-%E6%A3%80%E9%AA%8C%E5%92%8C"><span class="toc-text">2.2.1 计算 UDP 检验和</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-text">3 传输控制协议 TCP</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#3-1-tcp-%E6%9C%80%E4%B8%BB%E8%A6%81%E7%9A%84%E7%89%B9%E7%82%B9"><span class="toc-text">3.1 TCP 最主要的特点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-2-tcp-%E7%9A%84%E8%BF%9E%E6%8E%A5"><span class="toc-text">3.2 TCP 的连接</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-1-%E5%90%8C%E4%B8%80%E4%B8%AA%E5%90%8D%E8%AF%8D-socket%E6%9C%89%E5%A4%9A%E7%A7%8D%E4%B8%8D%E5%90%8C%E7%9A%84%E6%84%8F%E6%80%9D"><span class="toc-text">3.2.1 同一个名词 socket有多种不同的意思</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-text">4 可靠传输的工作原理</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#4-1-%E5%81%9C%E6%AD%A2%E7%AD%89%E5%BE%85%E5%8D%8F%E8%AE%AE"><span class="toc-text">4.1 停止等待协议</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-1-%E6%97%A0%E5%B7%AE%E9%94%99%E6%83%85%E5%86%B5"><span class="toc-text">4.1.1 无差错情况</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-2-%E7%A1%AE%E8%AE%A4%E4%B8%A2%E5%A4%B1%E5%92%8C%E7%A1%AE%E8%AE%A4%E8%BF%9F%E5%88%B0"><span class="toc-text">4.1.2 确认丢失和确认迟到 </span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-3-%E4%BF%A1%E9%81%93%E5%88%A9%E7%94%A8%E7%8E%87"><span class="toc-text">4.1.3 信道利用率</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-4-%E6%B5%81%E6%B0%B4%E7%BA%BF%E4%BC%A0%E8%BE%93"><span class="toc-text">4.1.4 流水线传输</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-2-%E8%BF%9E%E7%BB%AD-arq-%E5%8D%8F%E8%AE%AE"><span class="toc-text">4.2 连续 ARQ 协议</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-1-go-back-n-%E5%9B%9E%E9%80%80-n"><span class="toc-text">4.2.1 Go-back-N（回退 N）</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-text">5 TCP 报文段的首部格式</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#5-1-%E9%A6%96%E9%83%A8%E5%90%84%E4%B8%AA%E5%AD%97%E6%AE%B5%E7%9A%84%E5%90%AB%E4%B9%89"><span class="toc-text">5.1 首部各个字段的含义</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-1-1-%E6%BA%90%E7%AB%AF%E5%8F%A3%E5%92%8C%E7%9B%AE%E7%9A%84%E7%AB%AF%E5%8F%A3"><span class="toc-text">5.1.1 源端口和目的端口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-1-2-%E5%BA%8F%E5%8F%B7"><span class="toc-text">5.1.2 序号</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-1-3-%E7%A1%AE%E8%AE%A4%E5%8F%B7"><span class="toc-text">5.1.3 确认号</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-1-4-%E6%95%B0%E6%8D%AE%E5%81%8F%E7%A7%BB-%E5%8D%B3%E9%A6%96%E9%83%A8%E9%95%BF%E5%BA%A6"><span class="toc-text">5.1.4 数据偏移（即首部长度）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-1-5-%E4%BF%9D%E7%95%99"><span class="toc-text">5.1.5 保留</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-1-6-%E7%B4%A7%E6%80%A5-urg"><span class="toc-text">5.1.6 紧急 URG </span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-1-7-%E7%A1%AE%E8%AE%A4-ack"><span class="toc-text">5.1.7 确认 ACK</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-1-8-%E6%8E%A8%E9%80%81-psh"><span class="toc-text">5.1.8 推送 PSH</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-1-9-%E5%A4%8D%E4%BD%8D-rst"><span class="toc-text">5.1.9 复位 RST</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-1-10-%E5%90%8C%E6%AD%A5-syn"><span class="toc-text">5.1.10 同步 SYN</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-1-11-%E7%BB%88%E6%AD%A2-fin"><span class="toc-text">5.1.11 终止 FIN</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-1-12-%E7%AA%97%E5%8F%A3%E5%AD%97%E6%AE%B5"><span class="toc-text">5.1.12 窗口字段</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-1-13-%E6%A3%80%E9%AA%8C%E5%92%8C"><span class="toc-text">5.1.13 检验和</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-1-14-%E7%B4%A7%E6%80%A5%E6%8C%87%E9%92%88"><span class="toc-text">5.1.14 紧急指针</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-1-15-%E9%80%89%E9%A1%B9"><span class="toc-text">5.1.15 选项</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-1-16-%E5%85%B6%E4%BB%96%E9%80%89%E9%A1%B9"><span class="toc-text">5.1.16 其他选项</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-text">6 TCP 可靠传输的实现</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#6-1-%E4%BB%A5%E5%AD%97%E8%8A%82%E4%B8%BA%E5%8D%95%E4%BD%8D%E7%9A%84%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3"><span class="toc-text">6.1 以字节为单位的滑动窗口</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#6-1-1-%E5%8F%91%E9%80%81%E7%BC%93%E5%AD%98"><span class="toc-text">6.1.1 发送缓存</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-1-2-%E6%8E%A5%E6%94%B6%E7%BC%93%E5%AD%98"><span class="toc-text">6.1.2 接收缓存</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-2-%E8%B6%85%E6%97%B6%E9%87%8D%E4%BC%A0%E6%97%B6%E9%97%B4%E7%9A%84%E9%80%89%E6%8B%A9"><span class="toc-text">6.2 超时重传时间的选择</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#6-2-1-%E5%8A%A0%E6%9D%83%E5%B9%B3%E5%9D%87%E5%BE%80%E8%BF%94%E6%97%B6%E9%97%B4-rtts"><span class="toc-text">6.2.1 加权平均往返时间 RTTS</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-2-2-%E8%B6%85%E6%97%B6%E9%87%8D%E4%BC%A0%E6%97%B6%E9%97%B4rto"><span class="toc-text">6.2.2 超时重传时间RTO</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-2-3-karn-%E7%AE%97%E6%B3%95"><span class="toc-text">6.2.3 Karn 算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-2-4-%E4%BF%AE%E6%AD%A3%E7%9A%84-karn-%E7%AE%97%E6%B3%95"><span class="toc-text">6.2.4 修正的 Karn 算法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-3-%E9%80%89%E6%8B%A9%E7%A1%AE%E8%AE%A4-sack"><span class="toc-text">6.3 选择确认 SACK</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-text">7 TCP 的流量控制</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#7-1-%E5%88%A9%E7%94%A8%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E5%AE%9E%E7%8E%B0%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6"><span class="toc-text">7.1 利用滑动窗口实现流量控制</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#7-1-1-%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6%E4%B8%BE%E4%BE%8B"><span class="toc-text">7.1.1 流量控制举例</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-text">8 TCP的拥塞控制</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#8-1-%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6%E7%9A%84%E4%B8%80%E8%88%AC%E5%8E%9F%E7%90%86"><span class="toc-text">8.1 拥塞控制的一般原理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#8-1-1-%E5%BC%80%E7%8E%AF%E5%92%8C%E9%97%AD%E7%8E%AF%E6%8E%A7%E5%88%B6"><span class="toc-text">8.1.1 开环和闭环控制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-1-2-%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6%E4%B8%8E%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="toc-text">8.1.2 拥塞控制与流量控制的关系</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-2-tcp%E7%9A%84%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6%E6%96%B9%E6%B3%95"><span class="toc-text">8.2 TCP的拥塞控制方法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#8-2-1-%E6%85%A2%E5%BC%80%E5%A7%8B"><span class="toc-text">8.2.1 慢开始</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#8-2-1-1-%E6%85%A2%E5%BC%80%E5%A7%8B%E7%AE%97%E6%B3%95%E7%9A%84%E5%8E%9F%E7%90%86"><span class="toc-text">8.2.1.1 慢开始算法的原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-2-1-2-%E4%BC%A0%E8%BE%93%E8%BD%AE%E6%AC%A1"><span class="toc-text">8.2.1.2 传输轮次</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-2-2-%E6%8B%A5%E5%A1%9E%E9%81%BF%E5%85%8D"><span class="toc-text">8.2.2 拥塞避免</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-2-3-%E6%85%A2%E5%BC%80%E5%A7%8B%E5%92%8C%E6%8B%A5%E5%A1%9E%E9%81%BF%E5%85%8D%E7%AE%97%E6%B3%95%E7%9A%84%E5%AE%9E%E7%8E%B0%E4%B8%BE%E4%BE%8B"><span class="toc-text">8.2.3 慢开始和拥塞避免算法的实现举例</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#8-2-3-1-%E4%B9%98%E6%B3%95%E5%87%8F%E5%B0%8F"><span class="toc-text">8.2.3.1 乘法减小</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-2-3-2-%E5%8A%A0%E6%B3%95%E5%A2%9E%E5%A4%A7"><span class="toc-text">8.2.3.2 加法增大</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-2-4-%E5%BF%AB%E9%87%8D%E4%BC%A0"><span class="toc-text">8.2.4 快重传</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-2-5-%E5%BF%AB%E6%81%A2%E5%A4%8D"><span class="toc-text">8.2.5 快恢复</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-2-6-%E5%8F%91%E9%80%81%E7%AA%97%E5%8F%A3%E7%9A%84%E4%B8%8A%E9%99%90%E5%80%BC"><span class="toc-text">8.2.6 发送窗口的上限值</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-3-%E4%B8%BB%E5%8A%A8%E9%98%9F%E5%88%97%E7%AE%A1%E7%90%86aqm"><span class="toc-text">8.3 主动队列管理AQM</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#8-3-1-%E5%85%88%E8%BF%9B%E5%85%88%E5%87%BA-fifo%E5%A4%84%E7%90%86%E8%A7%84%E5%88%99"><span class="toc-text">8.3.1 “先进先出”FIFO处理规则</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-3-2-%E4%B8%BB%E5%8A%A8%E9%98%9F%E5%88%97%E7%AE%A1%E7%90%86aqm"><span class="toc-text">8.3.2 主动队列管理AQM</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-3-3-%E9%9A%8F%E6%9C%BA%E6%97%A9%E6%9C%9F%E6%A3%80%E6%B5%8Bred"><span class="toc-text">8.3.3 随机早期检测RED</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-text">9 TCP的传输连接管理</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#9-1-tcp-%E8%BF%9E%E6%8E%A5%E7%9A%84%E5%BB%BA%E7%AB%8B"><span class="toc-text">9.1 TCP 连接的建立</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-2-tcp-%E7%9A%84%E8%BF%9E%E6%8E%A5%E9%87%8A%E6%94%BE"><span class="toc-text">9.2 TCP 的连接释放</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-3-tcp-%E7%9A%84%E6%9C%89%E9%99%90%E7%8A%B6%E6%80%81%E6%9C%BA"><span class="toc-text">9.3 TCP 的有限状态机</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline" style="font-size: 17px;"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list" style="font-size: 16px;"><div class="aside-list-item"><a class="thumbnail" href="/2025/05/01/3-%E5%BE%AE%E8%B0%83%E9%A2%84%E8%AE%AD%E7%BB%83%E6%A8%A1%E5%9E%8B/" title="3. 微调预训练模型"><img src="https://venturebeat.com/wp-content/uploads/2023/05/Untitled-design-78.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="3. 微调预训练模型"/></a><div class="content"><a class="title" href="/2025/05/01/3-%E5%BE%AE%E8%B0%83%E9%A2%84%E8%AE%AD%E7%BB%83%E6%A8%A1%E5%9E%8B/" title="3. 微调预训练模型">3. 微调预训练模型</a><time datetime="2025-05-01T02:51:22.000Z" title="发表于 2025-05-01 10:51:22">2025-05-01</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/02/17/%E8%AE%BA%E6%96%87%E7%B2%BE%E8%AF%BB9%EF%BC%9AADSNet/" title="论文精读9：ADSNet"><img src="https://i.ytimg.com/vi/v5BoeTyOAhM/hq720.jpg?sqp=-oaymwE7CK4FEIIDSFryq4qpAy0IARUAAAAAGAElAADIQj0AgKJD8AEB-AH-CYACzgWKAgwIABABGFsgYShlMA8=&amp;rs=AOn4CLChXkjgk_egO-1uGInclI_lQe_MMg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="论文精读9：ADSNet"/></a><div class="content"><a class="title" href="/2025/02/17/%E8%AE%BA%E6%96%87%E7%B2%BE%E8%AF%BB9%EF%BC%9AADSNet/" title="论文精读9：ADSNet">论文精读9：ADSNet</a><time datetime="2025-02-17T09:09:52.000Z" title="发表于 2025-02-17 17:09:52">2025-02-17</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/01/27/2024%E5%B9%B4AI%E5%B9%B4%E5%BA%A6%E5%85%B3%E9%94%AE%E8%AF%8D/" title="2024年AI年度关键词"><img src="https://image.uisdc.com/wp-content/uploads/2025/01/banner2025012108482456.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="2024年AI年度关键词"/></a><div class="content"><a class="title" href="/2025/01/27/2024%E5%B9%B4AI%E5%B9%B4%E5%BA%A6%E5%85%B3%E9%94%AE%E8%AF%8D/" title="2024年AI年度关键词">2024年AI年度关键词</a><time datetime="2025-01-27T11:03:16.000Z" title="发表于 2025-01-27 19:03:16">2025-01-27</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/01/22/%E8%AE%BA%E6%96%87%E7%B2%BE%E8%AF%BB8%EF%BC%9AAutoPooling/" title="论文精读8：AutoPooling"><img src="https://haowallpaper.com/link/common/file/previewFileImg/16303799969041792" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="论文精读8：AutoPooling"/></a><div class="content"><a class="title" href="/2025/01/22/%E8%AE%BA%E6%96%87%E7%B2%BE%E8%AF%BB8%EF%BC%9AAutoPooling/" title="论文精读8：AutoPooling">论文精读8：AutoPooling</a><time datetime="2025-01-22T09:19:35.000Z" title="发表于 2025-01-22 17:19:35">2025-01-22</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url('https://pic1.zhimg.com/v2-2159a954d03d90c2d869bf962a7ef775_720w.jpg?source=172ae18b')"><div id="footer-wrap" style="padding: 5px 5px;"><div class="copyright">&copy;2024 - 2025 By 弘树</div><div id="running-time" style="font-size: 14px;"><script>setInterval(() => {
  let create_time = Math.round((new Date(2024, 1, 23).getTime()) / 1000);
  let timestamp = Math.round((new Date().getTime()) / 1000);
  let second = timestamp - create_time;
  let time = new Array(0, 0, 0, 0, 0);
  if (second >= 365 * 24 * 3600) {
      time[0] = parseInt(second / (365 * 24 * 3600));
      second %= 365 * 24 * 3600;
  }
  if (second >= 24 * 3600) {
      time[1] = parseInt(second / (24 * 3600));
      second %= 24 * 3600;
  }
  if (second >= 3600) {
      time[2] = parseInt(second / 3600);
      second %= 3600;
  }
  if (second >= 60) {
      time[3] = parseInt(second / 60);
      second %= 60;
  }
  if (second > 0) {
      time[4] = second;
  }
  currentTimeHtml = "本站已安全运行 " +
      time[0] + " 年 " +
      (time[1] + 31) + " 天 " +
      time[2] + " 时 " +
      time[3] + " 分 " +
      time[4] + " 秒";
  document.getElementById("running-time").innerHTML = currentTimeHtml;
  }, 1000);</script></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=4.12.0"></script><script src="/js/main.js?v=4.12.0"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.32/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"><script>if (!window.MathJax) {
  window.MathJax = {
    tex: {
      inlineMath: [['$', '$'], ['\\(', '\\)']],
      tags: 'ams'
    },
    chtml: {
      scale: 1.1
    },
    options: {
      renderActions: {
        findScript: [10, doc => {
          for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
            const display = !!node.type.match(/; *mode=display/)
            const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
            const text = document.createTextNode('')
            node.parentNode.replaceChild(text, node)
            math.start = {node: text, delim: '', n: 0}
            math.end = {node: text, delim: '', n: 0}
            doc.math.push(math)
          }
        }, '']
      }
    }
  }
  
  const script = document.createElement('script')
  script.src = 'https://cdn.jsdelivr.net/npm/mathjax@3.2.2/es5/tex-mml-chtml.min.js'
  script.id = 'MathJax-script'
  script.async = true
  document.head.appendChild(script)
} else {
  MathJax.startup.document.state(0)
  MathJax.texReset()
  MathJax.typesetPromise()
}</script><script>(() => {
  const loadUtterances = () => {
    let ele = document.createElement('script')
    ele.id = 'utterances_comment'
    ele.src = 'https://utteranc.es/client.js'
    ele.setAttribute('repo', 'NoyeArk/noyeark.github.io')
    ele.setAttribute('issue-term', 'pathname')
    const nowTheme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'photon-dark' : 'github-light'
    ele.setAttribute('theme', nowTheme)
    ele.crossOrigin = 'anonymous'
    ele.async = true
    document.getElementById('utterances-wrap').appendChild(ele)
  }

  const utterancesTheme = theme => {
    const iframe = document.querySelector('.utterances-frame')
    if (iframe) {
      const theme = theme === 'dark' ? 'photon-dark' : 'github-light'
      const message = {
        type: 'set-theme',
        theme: theme
      };
      iframe.contentWindow.postMessage(message, 'https://utteranc.es');
    }
  }

  btf.addGlobalFn('themeChange', utterancesTheme, 'utterances')

  if ('Utterances' === 'Utterances' || !false) {
    if (false) btf.loadComment(document.getElementById('utterances-wrap'), loadUtterances)
    else loadUtterances()
  } else {
    window.loadOtherComment = loadUtterances
  }
})()</script></div><script src="/js/jquery.js"></script><script src="/js/footer.js"></script><script src="/js/nav.js"></script><script>let tianliGPT_postSelector = '\#post \#article-container';let tianliGPT_key = 'iyiSf8ljbaf';</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js?v=4.12.0"></script></div></div></body></html>