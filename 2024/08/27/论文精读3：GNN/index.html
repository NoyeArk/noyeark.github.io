<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>论文精读3：GNN技术博客 | 诺亚方舟</title><meta name="author" content="弘树"><meta name="copyright" content="弘树"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="论文题目：A Gentle Introduction to Graph Neural Networks作者：Google发表时间：2021年  1 引言神经网络已适应利用图的结构和属性。我们探索构建图神经网络所需的组件——并激发它们背后的设计选择。  图就在我们身边；现实世界的对象通常是根据它们与其他事物的联系来定义的。一组对象以及它们之间的联系自然地表达为图形。十多年来，研究人员开发了对图数据">
<meta property="og:type" content="article">
<meta property="og:title" content="论文精读3：GNN技术博客">
<meta property="og:url" content="http://zhouzimu.top/2024/08/27/%E8%AE%BA%E6%96%87%E7%B2%BE%E8%AF%BB3%EF%BC%9AGNN/index.html">
<meta property="og:site_name" content="诺亚方舟">
<meta property="og:description" content="论文题目：A Gentle Introduction to Graph Neural Networks作者：Google发表时间：2021年  1 引言神经网络已适应利用图的结构和属性。我们探索构建图神经网络所需的组件——并激发它们背后的设计选择。  图就在我们身边；现实世界的对象通常是根据它们与其他事物的联系来定义的。一组对象以及它们之间的联系自然地表达为图形。十多年来，研究人员开发了对图数据">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://pic4.zhimg.com/v2-3601304d88287b2b8e1736ded4036a43_1440w.jpg?source=172ae18b">
<meta property="article:published_time" content="2024-08-27T01:19:16.000Z">
<meta property="article:modified_time" content="2024-11-14T03:10:12.000Z">
<meta property="article:author" content="弘树">
<meta property="article:tag" content="论文精读">
<meta property="article:tag" content="GNN">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://pic4.zhimg.com/v2-3601304d88287b2b8e1736ded4036a43_1440w.jpg?source=172ae18b"><link rel="shortcut icon" href="/img/favicon.jpg"><link rel="canonical" href="http://zhouzimu.top/2024/08/27/%E8%AE%BA%E6%96%87%E7%B2%BE%E8%AF%BB3%EF%BC%9AGNN/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css?v=4.12.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.5.1/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.32/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":true,"top_n_per_article":1,"unescape":true,"languages":{"hits_empty":"找不到您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":50,"languages":{"author":"作者: 弘树","link":"链接: ","source":"来源: 诺亚方舟","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.11.0/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '论文精读3：GNN技术博客',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-11-14 11:10:12'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
        if (t === 'dark') activateDarkMode()
        else if (t === 'light') activateLightMode()
      
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><link rel="stylesheet" href="/css/myStyle.css"><link rel="stylesheet" href="/css/tianli_gpt.css"><meta name="generator" content="Hexo 6.3.0"><link href="https://cdn.bootcss.com/KaTeX/0.11.1/katex.min.css" rel="stylesheet" /></head><body><div id="loading-box"><div class="wizard-scene"><div class="wizard-objects"><div class="wizard-square"></div><div class="wizard-circle"></div><div class="wizard-triangle"></div></div><div class="wizard"><div class="wizard-body"></div><div class="wizard-right-arm"><div class="wizard-right-hand"></div></div><div class="wizard-left-arm"><div class="wizard-left-hand"></div></div><div class="wizard-head"><div class="wizard-beard"></div><div class="wizard-face"><div class="wizard-adds"></div></div><div class="wizard-hat"><div class="wizard-hat-of-the-hat"></div><div class="wizard-four-point-star --first"></div><div class="wizard-four-point-star --second"></div><div class="wizard-four-point-star --third"></div></div></div></div></div></div><script>(()=>{
  const $loadingBox = document.getElementById('loading-box')
  const $body = document.body
  const preloader = {
    endLoading: () => {
      $body.style.overflow = ''
      $loadingBox.classList.add('loaded')
    },
    initLoading: () => {
      $body.style.overflow = 'hidden'
      $loadingBox.classList.remove('loaded')
    }
  }

  preloader.initLoading()
  window.addEventListener('load',() => { preloader.endLoading() })

  if (false) {
    document.addEventListener('pjax:send', () => { preloader.initLoading() })
    document.addEventListener('pjax:complete', () => { preloader.endLoading() })
  }
})()</script><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/pic_editor_1635545191.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">123</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">45</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">17</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 其他</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><i class="fa-fw fas fa-asterisk"></i><span> 归档</span></a></li><li><a class="site-page child" href="/update/"><i class="fa-fw fas fa-archive"></i><span> 更新日志</span></a></li></ul></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg fixed" id="page-header" style="background-image: url('https://pic4.zhimg.com/v2-3601304d88287b2b8e1736ded4036a43_1440w.jpg?source=172ae18b')"><nav id="nav"><span id="blog-info"><a href="/" title="诺亚方舟"><span class="site-name">诺亚方舟</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 其他</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><i class="fa-fw fas fa-asterisk"></i><span> 归档</span></a></li><li><a class="site-page child" href="/update/"><i class="fa-fw fas fa-archive"></i><span> 更新日志</span></a></li></ul></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">论文精读3：GNN技术博客</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="fa-fw post-meta-icon far fa-calendar-alt"></i><span class="post-meta-label">发表于</span><time datetime="2024-08-27T01:19:16.000Z" title="发表于 2024-08-27 09:19:16">2024-08-27</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E7%A7%91%E7%A0%94/">科研</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">13.5k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>40分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="论文精读3：GNN技术博客"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><blockquote>
<p><font color=green><strong>论文题目</strong></font>：A Gentle Introduction to Graph Neural Networks<br><font color=green><strong>作者</strong></font>：Google<br><font color=green><strong>发表时间</strong></font>：2021年</p>
</blockquote>
<h1 id="1-引言"><a href="#1-引言" class="headerlink" title="1 引言"></a>1 引言</h1><p>神经网络已适应利用图的结构和属性。我们探索构建图神经网络所需的组件——并激发它们背后的设计选择。</p>
<p><img src="/2024/08/27/%E8%AE%BA%E6%96%87%E7%B2%BE%E8%AF%BB3%EF%BC%9AGNN/image_fq6wObqoKX.png"></p>
<p>图就在我们身边；现实世界的对象通常是根据它们与其他事物的联系来定义的。一组对象以及它们之间的联系自然地表达为图形。十多年来，研究人员开发了对图数据进行操作的神经网络（称为图神经网络，或 <code>GNN</code>）。最近的发展提高了他们的能力和表达能力。我们开始看到抗菌药物发现等领域的实际应用，例如physics simulations（物理模拟）、fake news detection（假新闻检测）、traffic prediction（交通预测）和recommendation systems（推荐系统）。</p>
<p>本文探讨并解释了现代图神经网络。我们将这项工作分为四个部分。首先，我们看看哪种数据最自然地表达为图，以及一些常见的示例。其次，我们探讨图与其他类型数据的不同之处，以及使用图时必须做出的一些专门选择。第三，我们构建了一个现代 <code>GNN</code>，从该领域历史性的建模创新开始，遍历模型的每个部分。我们逐渐从简单的实现转向最先进的 <code>GNN</code>模型。第四，也是最后，我们提供了一个 <code>GNN</code>的playground，您可以在其中尝试真实的任务和数据集，以对 <code>GNN</code>模型的每个组件如何对其做出的预测做出贡献建立更强烈的直觉。</p>
<hr>
<h1 id="2-什么是图"><a href="#2-什么是图" class="headerlink" title="2 什么是图"></a>2 什么是图</h1><p>首先，让我们先确定什么是图：图表示实体（节点）集合之间的关系（边）。</p>
<p><img src="/2024/08/27/%E8%AE%BA%E6%96%87%E7%B2%BE%E8%AF%BB3%EF%BC%9AGNN/image_vKXNSClS9U.png"></p>
<p>为了进一步描述每个节点、边或整个图，我们可以在图的每个部分中存储信息。</p>
<p><img src="/2024/08/27/%E8%AE%BA%E6%96%87%E7%B2%BE%E8%AF%BB3%EF%BC%9AGNN/image_gVMoZXkPNU.png"></p>
<p>我们还可以通过将方向性与边（有向、无向）相关联来专门化图。</p>
<p><img src="/2024/08/27/%E8%AE%BA%E6%96%87%E7%B2%BE%E8%AF%BB3%EF%BC%9AGNN/image_6hiWD5Z6JK.png"></p>
<p>图是非常灵活的数据结构，如果现在这看起来很抽象，我们将在下一节中通过示例将其具体化。</p>
<hr>
<h1 id="3-图结构以及应用"><a href="#3-图结构以及应用" class="headerlink" title="3 图结构以及应用"></a>3 图结构以及应用</h1><p>你可能已经熟悉某些类型的图形数据，例如社交网络。然而，图表是一种极其强大且通用的数据表示形式，我们将展示两种您可能认为无法建模为图的数据类型：图像和文本。虽然违反直觉，但人们可以通过将图像和文本视为图形来更多地了解图像和文本的对称性和结构，并建立一种直觉，这将有助于理解其他不太像网格的图形数据，我们将在稍后讨论。</p>
<h2 id="3-1-图片作为图"><a href="#3-1-图片作为图" class="headerlink" title="3.1 图片作为图"></a>3.1 图片作为图</h2><p>我们通常将图像视为具有图像通道的矩形网格，将它们表示为数组（例如，$244 \times 244 \times 3 $浮点数）。<strong>另一种将图像视为具有规则结构的图，其中每个像素代表一个节点，并通过边缘连接到相邻像素。</strong>每个非边界像素正好有 8 个邻居，每个节点存储的信息是表示该像素的 <code>RGB</code>值的 3 维向量。</p>
<p>可视化图的连通性的一种方法是通过其邻接矩阵。我们对节点进行排序，在本例中，每个节点是一个简单的$ 5 \times 5$笑脸图像中的 25 个像素，并填充一个矩阵$n_{nodes}×n_{nodes}$。如果两个节点共享一条边，则有一个条目。请注意，下面这三种表示形式都是同一数据的不同视图。</p>
<p><img src="/2024/08/27/%E8%AE%BA%E6%96%87%E7%B2%BE%E8%AF%BB3%EF%BC%9AGNN/image_t7srwqhxyz.png"></p>
<h2 id="3-2-文本作为图"><a href="#3-2-文本作为图" class="headerlink" title="3.2 文本作为图"></a>3.2 文本作为图</h2><p>我们可以通过将索引与每个字符、单词或标记相关联，并将文本表示为这些索引的序列来数字化文本。这将创建一个简单的有向图，其中每个字符或索引都是一个节点，并通过边连接到其后面的节点。</p>
<p><img src="/2024/08/27/%E8%AE%BA%E6%96%87%E7%B2%BE%E8%AF%BB3%EF%BC%9AGNN/image_wAx0Wzdcot.png"></p>
<p>当然，在实践中，这通常不是文本和图像的编码方式：这些图形表示是多余的，因为所有图像和所有文本都将具有非常规则的结构。例如，图像的邻接矩阵具有带状结构，因为所有节点（像素）都连接在网格中。文本的邻接矩阵只是一条对角线，因为每个单词仅连接到前一个单词和下一个单词。</p>
<h2 id="3-3-其他可以表示为图的数据"><a href="#3-3-其他可以表示为图的数据" class="headerlink" title="3.3 其他可以表示为图的数据"></a>3.3 其他可以表示为图的数据</h2><p>图是描述你可能已经熟悉的数据的有用工具。让我们继续讨论结构更加异构的数据。在这些示例中，每个节点的邻居数量是可变的（与图像和文本的固定邻居大小相反）。除了图之外，这些数据很难以任何其他方式表达。</p>
<h3 id="分子作为图"><a href="#分子作为图" class="headerlink" title="分子作为图"></a><strong>分子作为图</strong></h3><p>分子是物质的组成部分，由 <code>3D</code>空间中的原子和电子构成。所有粒子都相互作用，但是当一对原子彼此保持稳定的距离时，我们说它们共享共价键。不同的原子对和键具有不同的距离（例如单键、双键）。将这个 <code>3D</code>对象描述为图是一个非常方便且常见的抽象，其中节点是原子，边是共价键。</p>
<p>以下是两种常见的分子及其相关图。</p>
<p><img src="/2024/08/27/%E8%AE%BA%E6%96%87%E7%B2%BE%E8%AF%BB3%EF%BC%9AGNN/image_cFGaz6nUQU.png"></p>
<blockquote>
<p>（左）香茅醛分子的 <code>3D</code>表示（中）分子中键的邻接矩阵（右）分子的图形表示</p>
</blockquote>
<p><img src="/2024/08/27/%E8%AE%BA%E6%96%87%E7%B2%BE%E8%AF%BB3%EF%BC%9AGNN/image_ip8P8VeINz.png"></p>
<blockquote>
<p>（左）咖啡因分子的 <code>3D</code>表示（中）分子中键的邻接矩阵（右）分子的图形表示</p>
</blockquote>
<h3 id="社交网络作为图表"><a href="#社交网络作为图表" class="headerlink" title="社交网络作为图表"></a><strong>社交网络作为图表</strong></h3><p>社交网络是研究人们、机构和组织集体行为模式的工具。我们可以通过将个体建模为节点并将他们的关系建模为边来构建表示人群的图。</p>
<p><img src="/2024/08/27/%E8%AE%BA%E6%96%87%E7%B2%BE%E8%AF%BB3%EF%BC%9AGNN/image_9eyY0CpO-a.png"></p>
<blockquote>
<p>（左）戏剧《奥赛罗》中的场景图像。（中）剧中角色之间互动的邻接矩阵。（右）这些交互的图形表示。</p>
</blockquote>
<p>与图像和文本数据不同，社交网络不具有相同的邻接矩阵。</p>
<p><img src="/2024/08/27/%E8%AE%BA%E6%96%87%E7%B2%BE%E8%AF%BB3%EF%BC%9AGNN/image_EtdVgrp4tK.png"></p>
<blockquote>
<p>（左）空手道锦标赛的图片。（中）空手道俱乐部中人与人之间互动的邻接矩阵。（右）这些交互的图形表示。</p>
</blockquote>
<h3 id="引用作为图表"><a href="#引用作为图表" class="headerlink" title="引用作为图表"></a><strong>引用作为图表</strong></h3><p>科学家在发表论文时经常引用其他科学家的工作。我们可以将这些引用网络可视化为一个图，其中每篇论文都是一个节点，每个有向边是一篇论文与另一篇论文之间的引用。此外，我们可以将每篇论文的信息添加到每个节点中，例如摘要的词嵌入。</p>
<h3 id="其他例子"><a href="#其他例子" class="headerlink" title="其他例子"></a><strong>其他例子</strong></h3><p>在计算机视觉中，我们有时想要标记视觉场景中的对象。然后，我们可以通过将这些对象视为节点，并将它们的关系视为边来构建图。机器学习模型，编程代码和数学方程也可以表述为图，其中变量是节点，边是将这些变量作为输入和输出的操作。您可能会在其中一些上下文中看到术语“数据流图”。</p>
<p>现实世界的图的结构在不同类型的数据之间可能有很大差异——有些图有很多节点，但它们之间的连接很少，反之亦然。图数据集在节点数、边数和节点连接性方面可能存在很大差异（在给定数据集内以及数据集之间）。</p>
<blockquote>
<p>对现实世界中发现的图进行汇总统计。数字取决于特征化决策。更多有用的统计数据和图表可以在 <code>KONECT</code>中找到。</p>
</blockquote>
<p><img src="/2024/08/27/%E8%AE%BA%E6%96%87%E7%B2%BE%E8%AF%BB3%EF%BC%9AGNN/image_hcrhCmF3v4.png"></p>
<hr>
<h1 id="4-图结构可以解决哪些类型的问题"><a href="#4-图结构可以解决哪些类型的问题" class="headerlink" title="4 图结构可以解决哪些类型的问题"></a>4 图结构可以解决哪些类型的问题</h1><p>我们已经描述了一些自然图表的示例，但是我们想要对这些数据执行什么任务？图上的预测任务一般分为三种类型：图级、节点级和边级。</p>
<p>在图级任务中，我们预测整个图的单个属性。对于节点级任务，我们预测图中每个节点的一些属性。对于边级任务，我们想要预测图中边的属性或存在。</p>
<p>对于上述三个级别的预测问题（图级、节点级和边级），我们将证明以下所有问题都可以使用单个模型类<code>GNN</code>来解决。但首先，让我们更详细地浏览一下三类图预测问题，并提供每一类的具体示例。</p>
<h2 id="4-1-图层面任务"><a href="#4-1-图层面任务" class="headerlink" title="4.1 图层面任务"></a>4.1 图层面任务</h2><p>在图级任务中，我们的目标是预测整个图的属性。例如，对于用图表表示的分子，我们可能想要预测该分子闻起来像什么，或者它是否会与与疾病有关的受体结合。</p>
<p><img src="/2024/08/27/%E8%AE%BA%E6%96%87%E7%B2%BE%E8%AF%BB3%EF%BC%9AGNN/image_nvJyfspVFU.png"></p>
<p>这类似于 <code>MNIST</code>和 <code>CIFAR</code>的图像分类问题，我们希望将标签与整个图像相关联。对于文本，类似的问题是情感分析，我们希望立即识别整个句子的情绪或情感。</p>
<h2 id="4-2-节点层面任务"><a href="#4-2-节点层面任务" class="headerlink" title="4.2 节点层面任务"></a>4.2 节点层面任务</h2><p>节点级任务涉及预测图中每个节点的身份或角色。</p>
<p>节点级预测问题的一个典型例子是扎克的空手道俱乐部。该数据集是一个单一的社交网络图，由在政治分歧后宣誓效忠两个空手道俱乐部之一的个人组成。故事是这样的，Hi 先生（教练）和 John H（管理员）之间的不和在空手道俱乐部中造成了分裂。节点代表各个空手道练习者，边代表空手道之外这些成员之间的互动。预测问题是对给定成员在不和之后是否忠诚于 Mr. Hi 或 John H 进行分类。在这种情况下，节点与讲师或管理员之间的距离与该标签高度相关。</p>
<p><img src="/2024/08/27/%E8%AE%BA%E6%96%87%E7%B2%BE%E8%AF%BB3%EF%BC%9AGNN/image_7IvlwWGN__.png"></p>
<blockquote>
<p>左边是问题的初始条件，右边是可能的解决方案，其中每个节点都根据联盟进行了分类。该数据集可用于其他图问题，例如无监督学习。</p>
</blockquote>
<p>按照图像类比，节点级预测问题类似于图像分割，我们试图标记图像中每个像素的作用。对于文本，类似的任务是预测句子中每个单词的词性（例如名词、动词、副词等）。</p>
<h2 id="4-3-边层面任务"><a href="#4-3-边层面任务" class="headerlink" title="4.3 边层面任务"></a>4.3 边层面任务</h2><p>图中剩下的预测问题是边缘预测。</p>
<p>边级推理的一个例子是图像场景理解。除了识别图像中的对象之外，深度学习模型还可用于预测它们之间的关系。我们可以将其表述为边缘级分类：给定代表图像中对象的节点，我们希望预测这些节点中的哪些共享边缘或该边缘的值是什么。如果我们希望发现实体之间的连接，我们可以考虑完全连接的图，并根据其预测值修剪边缘以得到稀疏图。</p>
<p><img src="/2024/08/27/%E8%AE%BA%E6%96%87%E7%B2%BE%E8%AF%BB3%EF%BC%9AGNN/image_ct5sZrdziU.png"></p>
<blockquote>
<p>在上面的 (b) 中，原始图像 (a) 被分割为五个实体：每位拳手、裁判、观众和垫子。 (c) 显示了这些实体之间的关系。</p>
</blockquote>
<p><img src="/2024/08/27/%E8%AE%BA%E6%96%87%E7%B2%BE%E8%AF%BB3%EF%BC%9AGNN/image_nAnNkW-KBj.png"></p>
<blockquote>
<p>在左侧，有一个根据之前的视觉场景构建的初始图。右侧是当根据模型的输出修剪一些连接时该图可能的边缘标记。</p>
</blockquote>
<hr>
<h1 id="5-在机器学习中使用图的挑战"><a href="#5-在机器学习中使用图的挑战" class="headerlink" title="5 在机器学习中使用图的挑战"></a>5 在机器学习中使用图的挑战</h1><p>那么，如何使用神经网络来解决这些不同的图形任务呢？第一步是考虑如何表示与神经网络兼容的图。</p>
<p>机器学习模型通常采用矩形或类似网格的数组作为输入。因此，如何以与深度学习兼容的格式表示它们并不是立即直观的。图形最多包含四种类型的信息，我们可能希望使用这些信息来进行预测：节点、边、全局上下文和连通性。前三个相对简单：例如，对于节点，我们可以通过为每个节点分配一个索引$i$并将特征存储在$node_i$中来形成结点特征矩阵$N$。虽然这些矩阵的样本数量可变，但无需任何特殊技术即可进行处理。</p>
<p>但是，表示图形的连通性更为复杂。也许最明显的选择是使用邻接矩阵，因为这很容易被拉伸。但是，这种表示方式有一些缺点。从示例数据集表中，我们看到图中的节点数量可能约为数百万个，并且每个节点的边数量可能变化很大。通常，这会导致非常稀疏的邻接矩阵，这在空间上效率低下。</p>
<p>另一个问题是，有许多邻接矩阵可以编码相同的连通性，并且不能保证这些不同的矩阵会在深度神经网络中产生相同的结果（也就是说，它们不是置换不变的）。</p>
<p>例如，之前的奥赛罗图可以等同于这两个邻接矩阵来描述。它也可以用节点的所有其他可能的排列来描述。</p>
<p><img src="/2024/08/27/%E8%AE%BA%E6%96%87%E7%B2%BE%E8%AF%BB3%EF%BC%9AGNN/image_joyQxkYkM9.png"></p>
<blockquote>
<p>表示同一图形的两个邻接矩阵。</p>
</blockquote>
<p>下面的示例显示了可以描述这个包含 4 个节点的小图的每个邻接矩阵。这已经是相当多的邻接矩阵——对于像奥赛罗这样的大例子，这个数字是站不住脚的。</p>
<p><img src="/2024/08/27/%E8%AE%BA%E6%96%87%E7%B2%BE%E8%AF%BB3%EF%BC%9AGNN/image_St7b8pdYuF.png"></p>
<blockquote>
<p>所有这些邻接矩阵都表示同一个图形。单击边以将其删除，在“虚拟边”上添加它，矩阵将相应地更新。</p>
</blockquote>
<p>表示稀疏矩阵的一种优雅且节省内存的方法是一种表示邻接列表。它们将节点$n_i$和$n_j$之间的边$e_k$联通性描述为邻接列表的第$k$个条目中的元组$(i,j)$。由于我们预计边的数量远低于邻接矩阵的条目数$(n^2_{nodes})$，因此我们避免了在图形的不连贯部分进行计算和存储。</p>
<p>为了使这个概念具体化，我们可以看到在此规范下如何表示不同图形中的信息：</p>
<p><img src="/2024/08/27/%E8%AE%BA%E6%96%87%E7%B2%BE%E8%AF%BB3%EF%BC%9AGNN/image_T4gtBZPG8Y.png"></p>
<blockquote>
<p>一边是小图，另一边是张量表示中的图信息。</p>
</blockquote>
<p>应该注意的是，该图使用每个节点&#x2F;边&#x2F;全局的标量值，但大多数实际的张量表示每个图属性都有向量。我们将处理大小为$[n_{nodes},node_{dim}]$的节点张量，而不是大小为$[n_{nodes}]$的节点张量，其他图形属性也是如此。</p>
<hr>
<h1 id="6-图神经网络"><a href="#6-图神经网络" class="headerlink" title="6 图神经网络"></a>6 图神经网络</h1><p>现在，图形的描述采用排列不变的矩阵格式，我们将描述使用图形神经网络 （GNN） 来解决图形预测任务。<strong>GNN 是对图的所有属性（节点、边、全局上下文）的可优化变换，它保留了图的对称性（排列不变性）。</strong>我们将使用 Gilmer 等人提出的“<strong>消息传递神经网络</strong>”框架来构建 GNN。</p>
<p>使用 Battaglia 等人介绍的 Graph Nets 架构原理图。GNN采用“图进图”的架构，这意味着这些模型类型接受图作为输入，将信息加载到其节点、边和全局上下文中，并逐步转换这些嵌入，<strong>而不改变输入图的连通性</strong>。</p>
<h2 id="6-1-最简单的GNN"><a href="#6-1-最简单的GNN" class="headerlink" title="6.1 最简单的GNN"></a>6.1 最简单的GNN</h2><p>通过我们上面构建的图形的数值表示（使用向量而不是标量），我们现在已经准备好构建 <code>GNN</code>。我们将从最简单的 <code>GNN</code>架构开始，在这个架构中，我们学习所有图形属性（节点、边、全局）的新嵌入，但我们还没有使用图形的连通性。</p>
<p>这个<code>GNN</code>在图的每个分量上都使用一个单独的多层感知器（<code>MLP</code>）（或你最喜欢的可微模型），我们称之为<code>GNN</code>层。对于每个节点向量，我们应用 <code>MLP</code>并返回一个学习到的节点向量。我们对每条边都做同样的事情，学习每条边的嵌入，也对全局上下文向量做同样的事情，学习整个图的单个嵌入。</p>
<p><img src="/2024/08/27/%E8%AE%BA%E6%96%87%E7%B2%BE%E8%AF%BB3%EF%BC%9AGNN/image_PT6NcErG-a.png"></p>
<blockquote>
<p>简单<code>GNN</code>的单层。图形是输入，每个分量$ (V,E,U)$都由<code>MLP</code>更新以生成新图形。每个函数下标表示<code>GNN</code>模型第$  n  $层的不同图形属性的单独函数。</p>
</blockquote>
<p>与神经网络模块或层一样，我们可以将这些<code>GNN</code>层堆叠在一起。</p>
<p>由于 <code>GNN</code> 不会更新输入图的连通性，因此我们可以使用与输入图相同的邻接列表和相同数量的特征向量来描述 <code>GNN</code> 的输出图。但是，输出图更新了嵌入，因为 <code>GNN</code> 更新了每个节点、边和全局上下文表示。</p>
<h2 id="6-2-通过Pooling信息进行GNN预测"><a href="#6-2-通过Pooling信息进行GNN预测" class="headerlink" title="6.2 通过Pooling信息进行GNN预测"></a>6.2 通过Pooling信息进行GNN预测</h2><p>我们已经构建了一个简单的<code>GNN</code>，但是我们如何在上面描述的任何任务中做出预测呢？</p>
<p>我们将考虑二元分类的情况，但这个框架可以很容易地扩展到多类或回归情况。如果任务是对节点进行二元预测，并且图形已经包含节点信息，则方法很简单：对于每个节点嵌入，应用线性分类器。</p>
<p><img src="/2024/08/27/%E8%AE%BA%E6%96%87%E7%B2%BE%E8%AF%BB3%EF%BC%9AGNN/image_3KzHFjgayz.png"></p>
<blockquote>
<p>我们可以想象一个社交网络，我们希望通过不使用用户数据（节点）来匿名化用户数据（节点），只使用关系数据（边缘）。此类方案的一个实例是我们在“节点级任务”小节中指定的节点任务。在空手道俱乐部的例子中，这只是使用人们之间的交往次数来确定与Hi先生或John H的联盟。</p>
</blockquote>
<p>不管有多少个顶点，这里只有一个全连接层，所有顶点都会共享这一个全连接层的参数。</p>
<p>然而，事情并不总是那么简单。例如，可能将图形中的信息存储在边中，但节点中没有信息，但仍需要对节点进行预测。我们需要一种方法来从边缘收集信息，并将它们提供给节点进行预测。我们可以通过池化来做到这一点。池化分两个步骤进行：</p>
<ol>
<li>对于要池化的每个项目，收集它们的每个嵌入并将它们连接到一个矩阵中。</li>
<li>然后，通常通过求和运算对收集的嵌入进行聚合。</li>
</ol>
<p>用字母$\rho$表示池化操作，并表示我们正在从边收集到节点的信息，如$p_{E_{n} \rightarrow V_{n}}$。</p>
<p><img src="/2024/08/27/%E8%AE%BA%E6%96%87%E7%B2%BE%E8%AF%BB3%EF%BC%9AGNN/image_vbWYkvFanZ.png"></p>
<blockquote>
<p>从这个点相邻的边中收集信息。</p>
</blockquote>
<p>因此，如果我们只有边的特征，并且试图预测二分类节点信息，我们可以使用池化将信息路由（或传递）到它需要去的地方。该模型如下所示。</p>
<p><img src="/2024/08/27/%E8%AE%BA%E6%96%87%E7%B2%BE%E8%AF%BB3%EF%BC%9AGNN/image_uSr14nIAY4.png"></p>
<p>如果我们只有节点级的特征，并且试图预测二分类边信息，则模型如下所示。</p>
<p><img src="/2024/08/27/%E8%AE%BA%E6%96%87%E7%B2%BE%E8%AF%BB3%EF%BC%9AGNN/image_S381a_n2hs.png"></p>
<p>此类场景的一个示例是我们在“边级别任务”子部分中指定的边缘任务。节点可以被识别为图像实体，我们正在尝试对顶点进行二分类。</p>
<p><img src="/2024/08/27/%E8%AE%BA%E6%96%87%E7%B2%BE%E8%AF%BB3%EF%BC%9AGNN/image_xsn633-ibJ.png"></p>
<blockquote>
<p>这是预测分子性质的常见情况。例如，我们有原子信息、连通性，我们想知道分子的毒性（有毒&#x2F;无毒），或者它是否具有特定的气味（玫瑰&#x2F;非玫瑰）。</p>
</blockquote>
<p>在我们的示例中，分类模型$c$可以很容易地替换为任何可微模型，或者使用广义线性模型适应多类分类。</p>
<p><img src="/2024/08/27/%E8%AE%BA%E6%96%87%E7%B2%BE%E8%AF%BB3%EF%BC%9AGNN/image_tQxM_wRI0M.png"></p>
<blockquote>
<p>使用 <code>GNN</code>模型的端到端预测任务。</p>
</blockquote>
<p>现在我们已经证明了我们可以构建一个简单的<code>GNN</code>模型，并通过在图形的不同部分之间路由信息来进行二元预测。这种池化技术将作为构建更复杂的<code>GNN</code>模型的构建块。如果我们有新的图形属性，我们只需要定义如何将信息从一个属性传递到另一个属性。</p>
<p>请注意，在这个最简单的 <code>GNN</code>公式中，我们根本没有在 <code>GNN</code>层内部使用图形的连通性。每个节点都是独立处理的，每个边以及全局上下文都是独立处理的。我们仅在汇集信息进行预测时才使用连通性。</p>
<h2 id="6-3-在图形的各个部分之间传递消息"><a href="#6-3-在图形的各个部分之间传递消息" class="headerlink" title="6.3 在图形的各个部分之间传递消息"></a>6.3 在图形的各个部分之间传递消息</h2><p>我们可以通过在<code>GNN</code>层中使用池化来做出更复杂的预测，以便使我们学习的嵌入意识到图的连通性。我们可以使用消息传递来做到这一点，其中相邻节点或边交换信息并影响彼此的更新嵌入。</p>
<p>消息传递分三个步骤进行：</p>
<ol>
<li>对于图中的每个节点，收集所有相邻节点嵌入（或消息），这就是上面描述的$g$函数</li>
<li>通过聚合函数（如$sum$）聚合所有消息</li>
<li>所有池化消息都通过更新函数传递，该函数通常是学习的神经网络</li>
</ol>
<p>正如池化可以应用于节点或边一样，消息传递也可以发生在节点或边之间。这些步骤是利用图形连通性的关键。我们将在 <code>GNN</code>层中构建更详细的消息传递进行改变，从而产生具有增强表现和效果的 <code>GNN</code>模型。</p>
<p><img src="/2024/08/27/%E8%AE%BA%E6%96%87%E7%B2%BE%E8%AF%BB3%EF%BC%9AGNN/image__rSr-EEiHU.png"></p>
<p>当应用一次时，此操作序列是最简单的消息传递 GNN 层类型。</p>
<p>这让人想起标准卷积：从本质上讲，消息传递和卷积是聚合和处理元素邻居信息以更新元素值的操作。在图结构中，元素是一个节点，而在图像中，元素是一个像素。但是，图结构中相邻节点的数量可以是可变的，这与图像中每个像素都有一定数量的相邻元素不同。</p>
<p>通过将传递<code>GNN</code>层的消息堆叠在一起，节点最终可以整合来自整个图的信息：在三层之后，一个节点拥有距离它三步远的节点的信息。</p>
<p>我们可以更新我们的架构图，以包含这个新的节点信息源：</p>
<p><img src="/2024/08/27/%E8%AE%BA%E6%96%87%E7%B2%BE%E8%AF%BB3%EF%BC%9AGNN/image_37yaXT5EVs.png"></p>
<blockquote>
<p><code>GCN</code>架构示意图，该架构通过汇集距离为 1 度的相邻节点来更新图形的节点表示。</p>
</blockquote>
<h3 id="6-3-1-学习边表示"><a href="#6-3-1-学习边表示" class="headerlink" title="6.3.1 学习边表示"></a>6.3.1 学习边表示</h3><p>我们的数据集并不总是包含所有类型的信息（节点、边缘和全局上下文）。当我们想对节点进行预测，但我们的数据集只有边信息时，我们在上面展示了如何使用池化将信息从边缘路由到节点，但仅限于模型的最后预测步骤。我们可以使用消息传递在 GNN 层内的节点和边之间共享信息。</p>
<p>我们可以采用与之前使用相邻节点信息相同的方式合并来自相邻边缘的信息，即首先汇集边缘信息，使用更新函数对其进行转换，然后存储它。</p>
<p>然而，存储在图中的节点和边缘信息不一定具有相同的大小或形状，因此如何将它们组合起来并不清楚。一种方法是学习从边空间到节点空间的线性映射，反之亦然。或者，可以在更新功能之前将它们连接在一起。</p>
<p><img src="/2024/08/27/%E8%AE%BA%E6%96%87%E7%B2%BE%E8%AF%BB3%EF%BC%9AGNN/image__tpkTS7kg6.png"></p>
<blockquote>
<p>消息传递层的架构示意图。第一步“准备”一条消息，该消息由来自边缘及其连接节点的信息组成，然后将消息“传递”到节点。</p>
</blockquote>
<p>在构建 <code>GNN</code>时，我们更新哪些图形属性以及以何种顺序更新它们是设计决策之一。我们可以选择是在边缘嵌入之前更新节点嵌入，还是相反。这是一个开放的研究领域，有各种各样的解决方案——例如，我们可以以“编织”的方式进行更新，其中，我们有四个更新的表示，它们被组合成新的节点和边表示：节点到节点（线性）、边到边（线性）、节点到边（边缘层）、边到节点（节点层）。</p>
<p><img src="/2024/08/27/%E8%AE%BA%E6%96%87%E7%B2%BE%E8%AF%BB3%EF%BC%9AGNN/image_IhhV2PPxOr.png"></p>
<blockquote>
<p>我们可以在GNN层中结合边缘和节点表示的一些不同方式。</p>
</blockquote>
<h3 id="6-3-2-添加全局表示"><a href="#6-3-2-添加全局表示" class="headerlink" title="6.3.2 添加全局表示"></a>6.3.2 添加全局表示</h3><p>到目前为止，我们所描述的网络存在一个缺陷：即使我们多次应用消息传递，在图中彼此相距很远的节点可能永远无法有效地相互传输信息。对于一个节点，如果我们有 k 层，信息将在最多 k 步之外传播。如果预测任务依赖于相距很远的节点或节点组，这可能是一个问题。一种解决方案是让所有节点能够相互传递信息。不幸的是，对于大型图形来说，这很快就会变得计算成本高昂（尽管这种方法被称为“虚拟边缘”，已被用于分子等小型图形）。</p>
<p>此问题的一种解决方案是使用图形（U） 的全局表示，该图形有时称为<strong>主节点</strong>或上下文向量。这个全局上下文向量连接到网络中的所有其他节点和边，并且可以充当它们之间的桥梁来传递信息，从而为整个图形构建表示。这创建了比以其他方式学习的更丰富、更复杂的图形表示。</p>
<p><img src="/2024/08/27/%E8%AE%BA%E6%96%87%E7%B2%BE%E8%AF%BB3%EF%BC%9AGNN/image_ESud7vRbvz.png"></p>
<blockquote>
<p>利用全局表示的图形网络架构示意图。</p>
</blockquote>
<p>在这个视图中，所有图形属性都学习了表示，因此我们可以在池化过程中通过调节我们感兴趣的属性相对于其余属性的信息来利用它们。例如，对于一个节点，我们可以考虑来自相邻节点、连接边和全局信息的信息。为了在所有这些可能的信息源上调节嵌入的新节点，我们可以简单地将它们连接起来。此外，我们还可以通过线性映射将它们映射到同一空间，然后添加它们或应用特征调制层，这可以被认为是一种特殊的注意力机制。</p>
<p><img src="/2024/08/27/%E8%AE%BA%E6%96%87%E7%B2%BE%E8%AF%BB3%EF%BC%9AGNN/image_-8WGYexIXC.png"></p>
<blockquote>
<p>基于其他三个嵌入（相邻节点、相邻边、全局）调节一个节点信息的原理图。此步骤对应于 Graph Nets 层中的节点操作。</p>
</blockquote>
<hr>
<h1 id="7-GNN实验"><a href="#7-GNN实验" class="headerlink" title="7 GNN实验"></a>7 GNN实验</h1><p>我们在这里描述了各种各样的 GNN 组件，但它们在实践中实际上有何不同？这个 GNN playground让你可以看到这些不同的组件和架构如何有助于 GNN 学习真实任务的能力。</p>
<p>我们的 Playground 展示了一个带有小分子图的图形级预测任务。我们使用 Leffingwell 气味数据集，它由具有相关气味感知（标签）的分子组成。预测分子结构（图形）与其气味的关系是一个跨越化学、物理学、神经科学和机器学习的 100 年历史的问题。</p>
<p>为了简化这个问题，我们只考虑每个分子一个二进制标签，根据专业调香师的标记，对分子图是否闻起来“刺鼻”进行分类。如果一个分子具有强烈、醒目的气味，我们就说它具有“刺鼻”的气味。例如，可能含有“烯丙醇”分子的大蒜和芥末就具有这种品质。分子 <code>piperitone</code>通常用于薄荷味糖果，也被描述为具有刺激性气味。</p>
<p>我们将每个分子表示为一个图形，其中原子是包含其原子身份（碳、氮、氧、氟）的独热编码的节点，键是包含一热编码其键类型（单键、双键、三键或芳香族）的边。</p>
<p>我们将使用顺序GNN层构建针对此问题的通用建模，然后使用带有Sigmoid激活的线性模型进行分类。我们的 GNN 的设计空间有许多可以自定义模型的组件：</p>
<ol>
<li><strong>GNN 层数</strong>：也称为深度</li>
<li><strong>更新时每个属性的维度</strong>：更新函数是一个 1 层 MLP，具有 relu 激活函数和用于激活归一化的层范数</li>
<li><strong>池化中使用的聚合函数</strong>：最大值、平均值或总和</li>
<li><strong>更新的图形属性</strong>：或消息传递的样式：节点、边和全局表示。我们通过布尔开关（打开或关闭）来控制它们。基线模型将是一个与图形无关的 GNN（所有消息传递），它将最后的所有数据聚合到一个单一的全局属性中。切换所有消息传递函数会产生 GraphNets 架构</li>
</ol>
<p>为了更好地理解GNN如何学习图形的任务优化表示，我们还研究了GNN的倒数第二层激活。这些“图嵌入”是 GNN 模型在预测之前的输出。由于我们使用广义线性模型进行预测，因此线性映射足以让我们了解我们如何围绕决策边界学习表示。</p>
<p>由于这些是高维向量，我们通过主成分分析（PCA）将它们简化为二维。一个完美的模型可以查看单独的标记数据，但由于我们正在降低维度并且也有不完美的模型，所以这个边界可能更难看到。</p>
<p>尝试使用不同的模型架构来构建您的直觉。例如，查看是否可以编辑左侧的分子以增加模型预测。对于不同的模型架构，相同的编辑是否具有相同的效果？</p>
<p><img src="/2024/08/27/%E8%AE%BA%E6%96%87%E7%B2%BE%E8%AF%BB3%EF%BC%9AGNN/image_wRS-X5R0ho.png"></p>
<blockquote>
<p>编辑分子以查看预测如何变化，或更改模型参数以加载不同的模型。在散点图中选择不同的分子。</p>
</blockquote>
<h2 id="7-1-一些经验性的GNN设计经验"><a href="#7-1-一些经验性的GNN设计经验" class="headerlink" title="7.1 一些经验性的GNN设计经验"></a>7.1 一些经验性的GNN设计经验</h2><p>在探索上述架构选择时，您可能已经发现某些模型比其他模型具有更好的性能。是否有一些明确的GNN设计选择会给我们带来更好的性能？例如，较深的GNN模型是否比较浅的GNN模型表现更好？或者在聚合函数之间是否有明确的选择？答案将取决于数据，甚至特征化和构建图形的不同方式也会给出不同的答案。</p>
<p>通过下面的交互式图形，我们探索了 GNN 架构的空间以及在几个主要设计选择中执行此任务的性能：消息传递的样式、嵌入的维度、层数和聚合操作类型。</p>
<p>散点图中的每个点都代表一个模型：$x$轴是可训练变量的数量，$y $轴是性能。将鼠标悬停在某个点上可查看 GNN 架构参数。</p>
<p><img src="/2024/08/27/%E8%AE%BA%E6%96%87%E7%B2%BE%E8%AF%BB3%EF%BC%9AGNN/image_JjK7uZZ10p.png"></p>
<blockquote>
<p>每个模型的性能与其可训练变量数量的散点图。将鼠标悬停在某个点上可查看 GNN 架构参数。</p>
</blockquote>
<p>首先要注意的是，令人惊讶的是，更多的参数确实与更高的性能相关。GNN是一种参数效率非常高的模型类型：即使是少量的参数（$3k$），我们已经可以找到高性能的模型。</p>
<h3 id="7-1-1-不同属性嵌入"><a href="#7-1-1-不同属性嵌入" class="headerlink" title="7.1.1 不同属性嵌入"></a>7.1.1 不同属性嵌入</h3><p>接下来，我们可以查看基于不同图形属性的学习表示的维度聚合的性能分布。</p>
<p><img src="/2024/08/27/%E8%AE%BA%E6%96%87%E7%B2%BE%E8%AF%BB3%EF%BC%9AGNN/image_0oAfSsL-oP.png"></p>
<blockquote>
<p>在不同的节点、边缘和全局维度上聚合模型的性能。</p>
</blockquote>
<p>我们可以注意到，维数较高的模型往往具有更好的均值和下限性能，但在最大值下没有发现相同的趋势。可以找到一些性能最佳的模型用于较小的尺寸。由于维数越高，参数数量越多，因此这些观测值与上图相辅相成。</p>
<h3 id="7-1-2-不同层数"><a href="#7-1-2-不同层数" class="headerlink" title="7.1.2 不同层数"></a>7.1.2 不同层数</h3><p>接下来，我们可以看到基于 GNN 层数的性能细分。</p>
<p><img src="/2024/08/27/%E8%AE%BA%E6%96%87%E7%B2%BE%E8%AF%BB3%EF%BC%9AGNN/image_OtIOQrSXnm.png"></p>
<blockquote>
<p>层数与模型性能的关系图，以及模型性能与参数数量的散点图。每个点都由层数着色。</p>
</blockquote>
<p>箱形图显示了类似的趋势，虽然平均性能往往随着层数的增加而增加，但性能最好的模型没有三层或四层，而是两层。此外，性能的下限随着四层的增加而降低。这种效应之前已经观察到，层数更多的GNN将在更远的距离上广播信息，并且可能会冒着其节点表示在许多连续迭代中被“稀释”的风险。</p>
<h3 id="7-1-3-不同汇聚操作"><a href="#7-1-3-不同汇聚操作" class="headerlink" title="7.1.3 不同汇聚操作"></a>7.1.3 不同汇聚操作</h3><p>我们的数据集是否有首选的聚合操作？下图根据聚合类型对性能进行了细分。</p>
<p><img src="/2024/08/27/%E8%AE%BA%E6%96%87%E7%B2%BE%E8%AF%BB3%EF%BC%9AGNN/image_a_55w_xDjJ.png"></p>
<blockquote>
<p>聚合类型与模型性能的图表，以及模型性能与参数数量的散点图。每个点都按聚合类型着色。</p>
</blockquote>
<p>总体而言，$sum $似乎对$  mean  $性能有非常轻微的改进，但$  max  $或$  mean  $可以给出同样好的模型。在查看 aggregation operations 的判别&#x2F;表达能力时，这对于上下文很有用。</p>
<p>之前的探索给出了好坏参半的信息。我们可以找到平均趋势，其中复杂性越高，性能越好，但我们可以找到明显的反例，其中参数、层数或维度较少的模型表现更好。一个更明显的趋势是关于相互传递信息的属性数量。</p>
<h3 id="7-1-4-不同消息传递类型"><a href="#7-1-4-不同消息传递类型" class="headerlink" title="7.1.4 不同消息传递类型"></a>7.1.4 不同消息传递类型</h3><p>在这里，我们根据消息传递的样式对性能进行细分。在这两个极端，我们考虑了在图形实体（“none”）之间不通信的模型和在节点、边和全局变量之间传递消息的模型。</p>
<p><img src="/2024/08/27/%E8%AE%BA%E6%96%87%E7%B2%BE%E8%AF%BB3%EF%BC%9AGNN/image__7PfTDb72b.png"></p>
<blockquote>
<p>消息传递与模型性能的关系图，以及模型性能与参数数量的散点图。每个点都由消息传递着色。</p>
</blockquote>
<p>总的来说，我们看到，图形属性进行通信的次数越多，平均模型的性能就越好。我们的任务以全局表示为中心，因此明确学习此属性也往往会提高性能。我们的节点表示似乎也比边表示更有用，这是有道理的，因为这些属性中加载了更多信息。</p>
<p>从这里开始，您可以采取许多方向来获得更好的性能。我们希望其中两个突出两个大方向，一个与更复杂的图形算法相关，另一个与图形本身有关。</p>
<p>到目前为止，我们的 GNN 是基于邻域的池化操作。有一些图形概念很难用这种方式表达，例如线性图形路径（连接的节点链）。设计新的机制，使图信息可以在GNN中被提取、执行和传播，这是当前的一个研究领域。</p>
<p>GNN研究的前沿之一不是制作新的模型和架构，而是“如何构建图形”，更准确地说，为图形注入可以利用的附加结构或关系。正如我们粗略地看到的，图形属性传达的次数越多，我们就越倾向于拥有更好的模型。在这种特殊情况下，我们可以考虑通过在节点之间添加额外的空间关系，添加不是键的边缘，或者在子图之间明确学习关系，使分子图的特征更加丰富。</p>
<hr>
<h1 id="8-相关技术"><a href="#8-相关技术" class="headerlink" title="8 相关技术"></a>8 相关技术</h1><p>接下来，我们将介绍与GNN相关的无数与图结构相关的主题。</p>
<h2 id="8-1-其他类型的图"><a href="#8-1-其他类型的图" class="headerlink" title="8.1 其他类型的图"></a>8.1 其他类型的图</h2><p>虽然我们只描述了每个属性的矢量化信息的图形，但图形结构更灵活，可以容纳其他类型的信息。幸运的是，消息传递框架足够灵活，以至于将 GNN 适应更复杂的图形结构通常是为了定义新的图形属性如何传递和更新信息。</p>
<p>例如，我们可以考虑多边图或多重图，其中一对节点可以共享多种类型的边，当我们想要根据节点的类型以不同的方式对节点之间的交互进行建模时，就会发生这种情况。例如，对于社交网络，我们可以根据关系类型（熟人、朋友、家人）指定边缘类型。GNN 可以通过为每种边类型设置不同类型的消息传递步骤来进行调整。我们还可以考虑嵌套图，例如，节点代表一个图，也称为超节点图。嵌套图可用于表示层次结构信息。例如，我们可以考虑一个分子网络，其中节点代表一个分子，如果我们有一种将一个分子转化为另一个分子的方法（反应），那么两个分子之间共享一条边。在这种情况下，我们可以通过让一个 GNN 在分子水平上学习表示，另一个在反应网络水平上学习表示，并在训练期间在它们之间交替学习。</p>
<p>另一种类型的图是超图，其中边可以连接到多个节点，而不仅仅是两个节点。对于给定的图，我们可以通过识别节点社区并分配连接到社区中所有节点的超边来构建超图。</p>
<p><img src="/2024/08/27/%E8%AE%BA%E6%96%87%E7%B2%BE%E8%AF%BB3%EF%BC%9AGNN/image_-gPj-dJDAl.png"></p>
<blockquote>
<p>更复杂图形的示意图。在左边，我们有一个多图的例子，它有三种边类型，包括有向边。在右边，我们有一个三级层次结构图，中间级节点是超节点。</p>
</blockquote>
<h2 id="8-2-GNN-中的采样图和批处理"><a href="#8-2-GNN-中的采样图和批处理" class="headerlink" title="8.2 GNN 中的采样图和批处理"></a>8.2 GNN 中的采样图和批处理</h2><p>训练神经网络的一种常见做法是使用在训练数据的随机常数大小（批量大小）子集（小批量）上计算的梯度来更新网络参数。这种做法给图形带来了挑战，因为彼此相邻的节点和边的数量是可变的，这意味着我们不能有一个恒定的批量大小。使用图形进行批处理的主要思想是创建子图，以保留较大图形的基本属性。这种图形采样操作高度依赖于上下文，并涉及从图形中子选择节点和边。这些操作在某些情况下（引文网络）可能有意义，而在其他上下文中，这些操作可能太强了（分子，其中子图仅代表一个新的、更小的分子）。如何对图表进行采样是一个开放的研究问题。</p>
<p>如果我们关心在邻域级别保持结构，一种方法是随机采样统一数量的节点，即我们的节点集。然后添加与节点集相邻的距离为$  k  $的相邻节点，包括它们的边。</p>
<p>每个邻域都可以被视为一个单独的图，GNN 可以在这些子图的批次上进行训练。可以忽略损失，只考虑节点集，因为所有相邻节点都有不完整的邻域。更有效的策略可能是首先随机抽取单个节点，将其邻域扩展到距离$  k  $，然后在扩展集内选择另一个节点。一旦构造了一定数量的节点、边或子图，就可以终止这些操作。如果上下文允许，我们可以通过选择初始节点集，然后对恒定数量的节点进行子采样（例如随机，或通过随机游走或 Metropolis 算法）来构建恒定大小的邻域。</p>
<p><img src="/2024/08/27/%E8%AE%BA%E6%96%87%E7%B2%BE%E8%AF%BB3%EF%BC%9AGNN/image_FZiAZGMY4X.png"></p>
<blockquote>
<p>对同一图形进行采样的四种不同方法。抽样策略的选择在很大程度上取决于上下文，因为它们将生成不同的图形统计信息分布（# 节点、#edges 等）。对于高度连通的图形，还可以对边进行二次采样。</p>
</blockquote>
<p>当图形足够大以至于无法放入内存中时，对图形进行采样尤为重要。激发新的架构和培训策略，例如 Cluster-GCN，我们预计图形数据集的规模将在未来继续增长。</p>
<h2 id="8-3-归纳偏置"><a href="#8-3-归纳偏置" class="headerlink" title="8.3 归纳偏置"></a>8.3 归纳偏置</h2><p>在构建模型以解决特定类型的数据上的问题时，我们希望将模型专业化以利用该数据的特征。当这成功完成时，我们通常会看到更好的预测性能、更短的训练时间、更少的参数和更好的泛化。</p>
<p>例如，在对图像进行标记时，我们希望利用这样一个事实，即无论它在图像的左上角还是右下角，狗仍然是狗。因此，大多数图像模型使用卷积，卷积是平移不变的。对于文本，标记的顺序非常重要，因此递归神经网络按顺序处理数据。此外，一个标记（例如“not”一词）的存在会影响句子其余部分的含义，因此我们需要能够“参与”文本其他部分的组件，而 BERT 和 GPT-3 等转换器模型可以做到这一点。这些是归纳偏差的一些例子，在这些例子中，我们正在识别数据中的对称性或规律性，并添加利用这些属性的建模组件。</p>
<p>在图的情况下，我们关心每个图分量（边、节点、全局）如何相互关联，因此我们寻找具有关系归纳偏差的模型。</p>
<p>模型应保留实体之间的显式关系（邻接矩阵）并保持图对称性（排列不变性）。我们预计实体之间交互很重要的问题将从图形结构中受益。具体来说，这意味着在集合上设计转换：节点或边上的操作顺序无关紧要，操作应该适用于可变数量的输入。</p>
<h2 id="8-4-比较聚合操作"><a href="#8-4-比较聚合操作" class="headerlink" title="8.4 比较聚合操作"></a>8.4 比较聚合操作</h2><p>汇集来自相邻节点和边缘的信息是任何相当强大的 GNN 架构中的关键步骤。由于每个节点的邻居数目都是可变的，并且由于我们想要一种可微分的方法来聚合此信息，因此我们希望使用与节点排序和提供的节点数无关的平滑聚合操作。</p>
<p>选择和设计最佳聚合操作是一个开放的研究课题。聚合操作的一个理想属性是相似的输入提供相似的聚合输出，反之亦然。一些非常简单的候选排列不变运算是 sum、mean 和 max。方差等汇总统计量也有效。所有这些都采用可变数量的 inputs，并提供相同的 output，无论 input ordering如何。让我们来探讨一下这些操作之间的区别。</p>
<p><img src="/2024/08/27/%E8%AE%BA%E6%96%87%E7%B2%BE%E8%AF%BB3%EF%BC%9AGNN/image_Njnzgc8a32.png"></p>
<blockquote>
<p>没有池化类型可以始终区分图形对，例如左侧的 max pooling 和右侧的 sum &#x2F; mean pooling。</p>
</blockquote>
<p>没有一个操作是绝对的最佳选择。当节点的相邻要素数量高度可变或您需要局部邻域特征的标准化视图时，均值运算可能很有用。当您想要高亮显示局部邻域中的单个突出要素时，max 操作可能非常有用。Sum 通过提供特征的局部分布的快照，在这两者之间提供平衡，但由于它未归一化，因此也可以突出显示异常值。在实践中，通常使用 sum。</p>
<p>设计聚合操作是一个开放的研究问题，它与集合上的机器学习相交。新方法，例如 Principal Neighborhood 聚合通过连接多个聚合操作并添加一个扩展函数来考虑这些操作，该函数取决于要聚合的实体的连接程度。同时，还可以设计特定于域的聚合操作。一个例子是 “Tetrahedral Chirality” 聚合运算符。</p>
<h2 id="8-5-GCN-作为子图函数近似器"><a href="#8-5-GCN-作为子图函数近似器" class="headerlink" title="8.5 GCN 作为子图函数近似器"></a>8.5 GCN 作为子图函数近似器</h2><p>使用 1 度邻居查找查看 k 层的 GCN（和 MPNN）的另一种方法是作为神经网络，该网络对大小为 k 的子图的学习嵌入进行操作。</p>
<p>当关注一个节点时，在 k 层之后，更新的节点表示具有所有邻居的有限视点，直到 k 距离，本质上是子图表示。边表示也是如此。</p>
<p>因此，GCN 正在收集所有可能的大小为 k 的子图，并从一个节点或边的有利位置学习向量表示。可能的子图的数量可以组合增长，因此从头开始枚举这些子图与像在 GCN 中那样动态构建它们可能会令人望而却步。</p>
<p><img src="/2024/08/27/%E8%AE%BA%E6%96%87%E7%B2%BE%E8%AF%BB3%EF%BC%9AGNN/image_pAFSwvkXrT.png"></p>
<h2 id="8-6-边和图形对偶"><a href="#8-6-边和图形对偶" class="headerlink" title="8.6 边和图形对偶"></a>8.6 边和图形对偶</h2><p>需要注意的一点是，边预测和节点预测虽然看起来不同，但通常归结为同一个问题：图$G$上的边预测任务可以表述为对的对偶的$G$节点级预测。</p>
<p>为了获得$G$的对偶，我们可以奖节点转换为边（将边转换为节点）。图形及其对偶包含相同的信息，只是以不同的方式表示。有时，此属性使一种表示中的问题比另一种表示中的问题更容易，例如傅里叶空间中的频率。 简而言之，要解决$G$上的边分类问题，可以考虑对$G$的dual 进行图卷积（这与$G$上的学习边表示相同），这个想法是用Dual-Primal Graph Convolutional Networks 开发的。</p>
<h2 id="8-7-将图卷积作为矩阵乘法，将矩阵乘法作为在图上的游走"><a href="#8-7-将图卷积作为矩阵乘法，将矩阵乘法作为在图上的游走" class="headerlink" title="8.7 将图卷积作为矩阵乘法，将矩阵乘法作为在图上的游走"></a>8.7 将图卷积作为矩阵乘法，将矩阵乘法作为在图上的游走</h2><p>我们已经讨论了很多关于图卷积和消息传递的内容，当然，这就提出了一个问题，即我们如何在实践中实现这些操作？在本节中，我们将探讨矩阵乘法、消息传递及其与遍历图形的一些连接。</p>
<p>我们要说明的第一点是，具有大小$n_{\text {nodes }} \times node <em>{\text {dim }}$为节点特征矩阵$X$的相邻矩阵$An</em>{\text {nodes }} \times n_{\text {nodes }}$的矩阵乘法实现了使用求和聚合的简单消息传递。设矩阵为$B&#x3D;AX$，我们可以观察到任何条目$B_{ij}$都可以表示为</p>
<p>$$<br>&lt;A_{\text {row }<em>{i}} \dot{X}<em>{\text {column }</em>{j}}&gt;&#x3D;A</em>{i, 1} X_{1, j}+A_{i, 2} X_{2, j}+\ldots+A_{i, n} X_{n, j}&#x3D;\sum_{A_{i, k}&gt;0} X_{k, j}<br>$$</p>
<p>因为$A_{i,k}$只有当和$node_k$之间存在边时$node_i$，才为1，所以内积本质上是收集维度$j$的所有节点特征值，这些值与$node_i$共享一条边。应该注意的是，此消息传递不会更新节点特征的表示，而只是池化相邻节点特征。但是这可以通过在矩阵乘法之前或之后通过$X$你最喜欢的可微变换（例如MLP）来轻松适应。</p>
<p>从这个角度来看，我们可以体会到使用邻接列表的好处。由于对$A$预期的稀疏性 ， 我们不必对$A_{i,j}$为0的所有值求和。只要我们有基于索引收集值的操作，我们应该能够只检索正条目。此外，这种无矩阵乘法使我们无需使用求和作为聚合运算。</p>
<p>我们可以想象，多次应用此操作可以让我们在更远的距离传播信息。从这个意义上说，矩阵乘法是遍历图的一种形式。当我们查看邻接矩阵的幂$A^K$时，这种关系也很明显。如果我们考虑矩阵$A^2$，项$A_{ij}^2$计算从$node_i$到$node_j$的所有长度为2的路径，并且可以表示为内积：</p>
<p>$$<br>&lt;A_{\text {rou }<em>{i}}, A_{\text {column }_{j}}&gt;&#x3D;A</em>{i, 1} A_{1, j}+A_{i, 2} A_{2, j}+\ldots+A_{i, n} A_{n, j}<br>$$</p>
<p>直觉是，第一项$a_{i,1}a_{1,j}$仅在两个条件下为正，一条边连接$node_i$和$node_1$，另一条边连接$node_ 1$和$node_j$。换句话说，两条边形成一条长度为 2 的路径，该路径从$node_i$经过$node_1$连接到$node_j$。由于求和，我们正在计算所有可能的中间节点。当我们考虑$A^3&#x3D;AA^2$时，这种直觉会延续下来以此类推至$A^k$。</p>
<p>关于我们如何将矩阵视为要探索的图形，存在更深层次的联系。</p>
<h2 id="8-8-注意力网络"><a href="#8-8-注意力网络" class="headerlink" title="8.8 注意力网络"></a>8.8 注意力网络</h2><p>在 graph 属性之间传递信息的另一种方式是通过 attention。例如，当我们考虑一个节点及其 1 度相邻节点的和聚合时，我们也可以考虑使用加权和。然后，挑战在于以排列不变的方式关联权重。一种方法是考虑一个标量评分函数，该函数根据节点对$f(node_i,node_j)$分配权重。在这种情况下，评分函数可以解释为测量相邻节点与中心节点的相关性的函数。权重可以标准化，例如使用 softmax 函数将大部分权重集中在与任务相关的节点最相关的邻居上。这个概念是 Graph Attention Networks （GAT） 的基础保留排列不变性，因为评分适用于成对的节点。一个常见的评分函数是内积，在评分之前，通常会通过线性映射将节点转换为查询和关键向量，以提高评分机制的表达能力。此外，为了可解释性，评分权重可以用作衡量边缘相对于任务的重要性的度量。</p>
<p><img src="/2024/08/27/%E8%AE%BA%E6%96%87%E7%B2%BE%E8%AF%BB3%EF%BC%9AGNN/image_CFUbTIlvOQ.png"></p>
<blockquote>
<p>一个节点相对于其相邻节点的注意力示意图。对于每条边，都会计算、规范化交互分数，并用于对节点嵌入进行加权。</p>
</blockquote>
<p>此外，Transformer可以被视为具有注意力机制的 GNN。在这个视图下，transformer 将几个元素（即字符标记）建模为全连接图中的节点，并且注意力机制为每个节点对分配边缘嵌入，用于计算注意力权重。区别在于实体之间连接的假设模式，GNN 假设稀疏模式，而 Transformer 对所有连接进行建模。</p>
<h2 id="8-9-图表解释和归属"><a href="#8-9-图表解释和归属" class="headerlink" title="8.9 图表解释和归属"></a>8.9 图表解释和归属</h2><p>在直接部署 GNN 时，我们可能会关心模型的可解释性，以建立可信度、调试或科学发现。我们想要解释的图形概念因上下文而异。例如，对于分子，我们可能关心特定子图的存在与否，而在引文网络中，我们可能关心文章的关联程度。由于图形概念的多样性，构建解释的方法有很多种。GNNExplainer将此问题转换为提取对任务最重要的最相关的子图。归因技术将 Ranked importance 值分配给与任务相关的图表部分。由于可以综合生成现实且具有挑战性的图形问题，因此 GNN 可以作为评估归因技术的严格且可重复的测试平台。</p>
<p><img src="/2024/08/27/%E8%AE%BA%E6%96%87%E7%B2%BE%E8%AF%BB3%EF%BC%9AGNN/image_yWJ6TZuhT8.png"></p>
<blockquote>
<p>图表上的一些可解释性技术的示意图。归因将排名值分配给图表属性。排名可以用作提取可能与任务相关的连接子图的基础。</p>
</blockquote>
<h2 id="8-10-生成模型"><a href="#8-10-生成模型" class="headerlink" title="8.10 生成模型"></a>8.10 生成模型</h2><p>除了学习图上的预测模型外，我们可能还关心学习图的生成模型。使用生成模型，我们可以通过从学习的分布中采样或通过完成给定起点的图形来生成新图形。一个相关的应用是新药的设计，其中需要具有特定特性的新型分子图作为治疗疾病的候选者。</p>
<p>图形生成模型的一个关键挑战在于对图形的拓扑进行建模，图形的大小可能会有很大差异并且有$N_{nodes}^2$项。一种解决方案是使用自动编码器框架直接对临界矩阵进行建模，就像对图像进行建模一样。对边缘是否存在的预测被视为二分类任务。可以通过仅预测已知边和不存在的边的子集来避免该$N_{nodes}^2$。graphVAE 学习对邻接矩阵中的正连接模式和一些非连接模式进行建模。</p>
<p>另一种方法是按顺序构建图形，从图形开始，然后迭代地应用离散操作，例如增加或减少节点和边缘。为了避免估计离散行动的梯度，我们可以使用策略梯度。这是通过自回归模型完成的，例如 RNN，或者在强化学习场景中。此外，有时可以将图形建模为仅包含语法元素的序列。</p>
<hr>
<h1 id="9-结论"><a href="#9-结论" class="headerlink" title="9 结论"></a>9 结论</h1><p>图形是一种强大而丰富的结构化数据类型，其优势和挑战与图像和文本截然不同。在本文中，我们概述了研究人员在构建基于神经网络的图形处理模型时提出的一些里程碑。我们已经介绍了使用这些架构时必须做出的一些重要设计选择，希望 GNN playground 可以直观地了解这些设计选择的经验结果是什么。近年来 GNN 的成功为各种新问题创造了巨大的机会，我们很高兴看到该领域将带来什么。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="http://zhouzimu.top">弘树</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="http://zhouzimu.top/2024/08/27/%E8%AE%BA%E6%96%87%E7%B2%BE%E8%AF%BB3%EF%BC%9AGNN/">http://zhouzimu.top/2024/08/27/论文精读3：GNN/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://zhouzimu.top" target="_blank">诺亚方舟</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E8%AE%BA%E6%96%87%E7%B2%BE%E8%AF%BB/">论文精读</a><a class="post-meta__tags" href="/tags/GNN/">GNN</a></div><div class="post_share"><div class="social-share" data-image="https://pic4.zhimg.com/v2-3601304d88287b2b8e1736ded4036a43_1440w.jpg?source=172ae18b" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i>码字不易，如果对你有帮助的话请喝一杯奶茶吧~</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/img/wechat.png" target="_blank"><img class="post-qr-code-img" src="/img/wechat.png" alt="微信"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="/img/alipay.png" target="_blank"><img class="post-qr-code-img" src="/img/alipay.png" alt="支付宝"/></a><div class="post-qr-code-desc">支付宝</div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2024/08/28/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E7%AC%AC7%E7%AB%A0%EF%BC%9A%E8%AF%AD%E6%B3%95%E5%88%B6%E5%AF%BC%E7%BF%BB%E8%AF%91/" title="编译原理第7章：语法制导翻译"><img class="cover" src="https://i.ytimg.com/vi/-chsZ-4yfHU/maxresdefault.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">编译原理第7章：语法制导翻译</div></div></a></div><div class="next-post pull-right"><a href="/2024/08/19/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E7%AC%AC4%E7%AB%A0%EF%BC%9A%E5%AD%98%E5%82%A8%E5%99%A8/" title="计算机组成原理第4章：存储器"><img class="cover" src="https://img.dramx.com/website/dramx/20210305153456_%E5%AD%98%E5%82%A8%E5%99%A8.jpeg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">计算机组成原理第4章：存储器</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2024/08/15/%E8%AE%BA%E6%96%87%E7%B2%BE%E8%AF%BB2%EF%BC%9ATraining-Free-Layout-Control-with-Cross-Attention-Guidance/" title="论文精读2：Training-Free Layout Control with Cross-Attention Guidance"><img class="cover" src="https://github.com/silent-chen/layout-guidance/raw/gh-page/resources/teaser.png?raw=true" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-08-15</div><div class="title">论文精读2：Training-Free Layout Control with Cross-Attention Guidance</div></div></a></div><div><a href="/2024/09/15/%E8%AE%BA%E6%96%87%E7%B2%BE%E8%AF%BB4%EF%BC%9AGAN/" title="论文精读4：GAN"><img class="cover" src="https://i0.wp.com/bdtechtalks.com/wp-content/uploads/2018/05/Generative-adversarial-networks-GAN-min-389357362-1527503338782.png?fit=2997%2C1840&ssl=1" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-09-15</div><div class="title">论文精读4：GAN</div></div></a></div><div><a href="/2024/11/14/%E8%AE%BA%E6%96%87%E7%B2%BE%E8%AF%BB5%EF%BC%9ADeep-Neural-Networks-for-YouTube-Recommendations/" title="论文精读5：DNN for YouTube Rec"><img class="cover" src="https://blog.acolyer.org/wp-content/uploads/2016/09/dnn-youtube-fig-7.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-11-14</div><div class="title">论文精读5：DNN for YouTube Rec</div></div></a></div><div><a href="/2024/07/27/%E8%AE%BA%E6%96%87%E7%B2%BE%E8%AF%BB1%EF%BC%9AAn-Attention-Free-Transformer/" title="论文精读1：An Attention Free Transformer"><img class="cover" src="https://th.bing.com/th/id/R.c711422d32a03183ff82c805e6837a5b?rik=hgP3vHF2D%2fyCGA&riu=http%3a%2f%2fwww.deeplearningdaily.com%2fwp-content%2fuploads%2f2021%2f06%2funofficial-pytorch-implementation-of-attention-free-transformer-aft-layers_60c5308a5335f.jpeg&ehk=tQubmdKcevvpCuBVL2VoQQ80Z%2bRnw1ORYVBowyf4VyE%3d&risl=&pid=ImgRaw&r=0" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-07-27</div><div class="title">论文精读1：An Attention Free Transformer</div></div></a></div></div></div><hr class="custom-hr"/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="utterances-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/pic_editor_1635545191.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">弘树</div><div class="author-info__description">在我坚定无比的内心，总以最坚强的节奏解开案情</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">123</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">45</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">17</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/NoyeArk"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/NoyeArk" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="mailto:horiki0@qq.com" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #4a7dbe;"></i></a><a class="social-icon" href="https://leetcode.cn/u/horiki/" target="_blank" title="Leetcode"><i class="fas fa-l" style="color: #59e285;"></i></a><a class="social-icon" href="https://www.kaggle.com/horiki" target="_blank" title="Kaggle"><i class="fas fa-k" style="color: #4a7dbe;"></i></a></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc" style="font-size: 15px;"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#1-%E5%BC%95%E8%A8%80"><span class="toc-text">1 引言</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#2-%E4%BB%80%E4%B9%88%E6%98%AF%E5%9B%BE"><span class="toc-text">2 什么是图</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#3-%E5%9B%BE%E7%BB%93%E6%9E%84%E4%BB%A5%E5%8F%8A%E5%BA%94%E7%94%A8"><span class="toc-text">3 图结构以及应用</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#3-1-%E5%9B%BE%E7%89%87%E4%BD%9C%E4%B8%BA%E5%9B%BE"><span class="toc-text">3.1 图片作为图</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-2-%E6%96%87%E6%9C%AC%E4%BD%9C%E4%B8%BA%E5%9B%BE"><span class="toc-text">3.2 文本作为图</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-3-%E5%85%B6%E4%BB%96%E5%8F%AF%E4%BB%A5%E8%A1%A8%E7%A4%BA%E4%B8%BA%E5%9B%BE%E7%9A%84%E6%95%B0%E6%8D%AE"><span class="toc-text">3.3 其他可以表示为图的数据</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E5%AD%90%E4%BD%9C%E4%B8%BA%E5%9B%BE"><span class="toc-text">分子作为图</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A4%BE%E4%BA%A4%E7%BD%91%E7%BB%9C%E4%BD%9C%E4%B8%BA%E5%9B%BE%E8%A1%A8"><span class="toc-text">社交网络作为图表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%95%E7%94%A8%E4%BD%9C%E4%B8%BA%E5%9B%BE%E8%A1%A8"><span class="toc-text">引用作为图表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B6%E4%BB%96%E4%BE%8B%E5%AD%90"><span class="toc-text">其他例子</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#4-%E5%9B%BE%E7%BB%93%E6%9E%84%E5%8F%AF%E4%BB%A5%E8%A7%A3%E5%86%B3%E5%93%AA%E4%BA%9B%E7%B1%BB%E5%9E%8B%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-text">4 图结构可以解决哪些类型的问题</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#4-1-%E5%9B%BE%E5%B1%82%E9%9D%A2%E4%BB%BB%E5%8A%A1"><span class="toc-text">4.1 图层面任务</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-2-%E8%8A%82%E7%82%B9%E5%B1%82%E9%9D%A2%E4%BB%BB%E5%8A%A1"><span class="toc-text">4.2 节点层面任务</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-3-%E8%BE%B9%E5%B1%82%E9%9D%A2%E4%BB%BB%E5%8A%A1"><span class="toc-text">4.3 边层面任务</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#5-%E5%9C%A8%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%B8%AD%E4%BD%BF%E7%94%A8%E5%9B%BE%E7%9A%84%E6%8C%91%E6%88%98"><span class="toc-text">5 在机器学习中使用图的挑战</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#6-%E5%9B%BE%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C"><span class="toc-text">6 图神经网络</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#6-1-%E6%9C%80%E7%AE%80%E5%8D%95%E7%9A%84GNN"><span class="toc-text">6.1 最简单的GNN</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-2-%E9%80%9A%E8%BF%87Pooling%E4%BF%A1%E6%81%AF%E8%BF%9B%E8%A1%8CGNN%E9%A2%84%E6%B5%8B"><span class="toc-text">6.2 通过Pooling信息进行GNN预测</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-3-%E5%9C%A8%E5%9B%BE%E5%BD%A2%E7%9A%84%E5%90%84%E4%B8%AA%E9%83%A8%E5%88%86%E4%B9%8B%E9%97%B4%E4%BC%A0%E9%80%92%E6%B6%88%E6%81%AF"><span class="toc-text">6.3 在图形的各个部分之间传递消息</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#6-3-1-%E5%AD%A6%E4%B9%A0%E8%BE%B9%E8%A1%A8%E7%A4%BA"><span class="toc-text">6.3.1 学习边表示</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-3-2-%E6%B7%BB%E5%8A%A0%E5%85%A8%E5%B1%80%E8%A1%A8%E7%A4%BA"><span class="toc-text">6.3.2 添加全局表示</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#7-GNN%E5%AE%9E%E9%AA%8C"><span class="toc-text">7 GNN实验</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#7-1-%E4%B8%80%E4%BA%9B%E7%BB%8F%E9%AA%8C%E6%80%A7%E7%9A%84GNN%E8%AE%BE%E8%AE%A1%E7%BB%8F%E9%AA%8C"><span class="toc-text">7.1 一些经验性的GNN设计经验</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#7-1-1-%E4%B8%8D%E5%90%8C%E5%B1%9E%E6%80%A7%E5%B5%8C%E5%85%A5"><span class="toc-text">7.1.1 不同属性嵌入</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-1-2-%E4%B8%8D%E5%90%8C%E5%B1%82%E6%95%B0"><span class="toc-text">7.1.2 不同层数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-1-3-%E4%B8%8D%E5%90%8C%E6%B1%87%E8%81%9A%E6%93%8D%E4%BD%9C"><span class="toc-text">7.1.3 不同汇聚操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-1-4-%E4%B8%8D%E5%90%8C%E6%B6%88%E6%81%AF%E4%BC%A0%E9%80%92%E7%B1%BB%E5%9E%8B"><span class="toc-text">7.1.4 不同消息传递类型</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#8-%E7%9B%B8%E5%85%B3%E6%8A%80%E6%9C%AF"><span class="toc-text">8 相关技术</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#8-1-%E5%85%B6%E4%BB%96%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%9B%BE"><span class="toc-text">8.1 其他类型的图</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-2-GNN-%E4%B8%AD%E7%9A%84%E9%87%87%E6%A0%B7%E5%9B%BE%E5%92%8C%E6%89%B9%E5%A4%84%E7%90%86"><span class="toc-text">8.2 GNN 中的采样图和批处理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-3-%E5%BD%92%E7%BA%B3%E5%81%8F%E7%BD%AE"><span class="toc-text">8.3 归纳偏置</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-4-%E6%AF%94%E8%BE%83%E8%81%9A%E5%90%88%E6%93%8D%E4%BD%9C"><span class="toc-text">8.4 比较聚合操作</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-5-GCN-%E4%BD%9C%E4%B8%BA%E5%AD%90%E5%9B%BE%E5%87%BD%E6%95%B0%E8%BF%91%E4%BC%BC%E5%99%A8"><span class="toc-text">8.5 GCN 作为子图函数近似器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-6-%E8%BE%B9%E5%92%8C%E5%9B%BE%E5%BD%A2%E5%AF%B9%E5%81%B6"><span class="toc-text">8.6 边和图形对偶</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-7-%E5%B0%86%E5%9B%BE%E5%8D%B7%E7%A7%AF%E4%BD%9C%E4%B8%BA%E7%9F%A9%E9%98%B5%E4%B9%98%E6%B3%95%EF%BC%8C%E5%B0%86%E7%9F%A9%E9%98%B5%E4%B9%98%E6%B3%95%E4%BD%9C%E4%B8%BA%E5%9C%A8%E5%9B%BE%E4%B8%8A%E7%9A%84%E6%B8%B8%E8%B5%B0"><span class="toc-text">8.7 将图卷积作为矩阵乘法，将矩阵乘法作为在图上的游走</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-8-%E6%B3%A8%E6%84%8F%E5%8A%9B%E7%BD%91%E7%BB%9C"><span class="toc-text">8.8 注意力网络</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-9-%E5%9B%BE%E8%A1%A8%E8%A7%A3%E9%87%8A%E5%92%8C%E5%BD%92%E5%B1%9E"><span class="toc-text">8.9 图表解释和归属</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-10-%E7%94%9F%E6%88%90%E6%A8%A1%E5%9E%8B"><span class="toc-text">8.10 生成模型</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#9-%E7%BB%93%E8%AE%BA"><span class="toc-text">9 结论</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline" style="font-size: 17px;"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list" style="font-size: 16px;"><div class="aside-list-item"><a class="thumbnail" href="/2025/05/02/5-%E6%95%B0%E6%8D%AE%E9%9B%86/" title="「HFLLM」5-数据集"><img src="https://cdn.mos.cms.futurecdn.net/gHfBJ6FBHKnLbW36hEDvgV.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="「HFLLM」5-数据集"/></a><div class="content"><a class="title" href="/2025/05/02/5-%E6%95%B0%E6%8D%AE%E9%9B%86/" title="「HFLLM」5-数据集">「HFLLM」5-数据集</a><time datetime="2025-05-02T08:26:25.000Z" title="发表于 2025-05-02 16:26:25">2025-05-02</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/05/01/3-%E5%BE%AE%E8%B0%83%E9%A2%84%E8%AE%AD%E7%BB%83%E6%A8%A1%E5%9E%8B/" title="「HFLLM」3. 微调预训练模型"><img src="https://venturebeat.com/wp-content/uploads/2023/05/Untitled-design-78.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="「HFLLM」3. 微调预训练模型"/></a><div class="content"><a class="title" href="/2025/05/01/3-%E5%BE%AE%E8%B0%83%E9%A2%84%E8%AE%AD%E7%BB%83%E6%A8%A1%E5%9E%8B/" title="「HFLLM」3. 微调预训练模型">「HFLLM」3. 微调预训练模型</a><time datetime="2025-05-01T02:51:22.000Z" title="发表于 2025-05-01 10:51:22">2025-05-01</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/02/17/%E8%AE%BA%E6%96%87%E7%B2%BE%E8%AF%BB9%EF%BC%9AADSNet/" title="论文精读9：ADSNet"><img src="https://i.ytimg.com/vi/v5BoeTyOAhM/hq720.jpg?sqp=-oaymwE7CK4FEIIDSFryq4qpAy0IARUAAAAAGAElAADIQj0AgKJD8AEB-AH-CYACzgWKAgwIABABGFsgYShlMA8=&amp;rs=AOn4CLChXkjgk_egO-1uGInclI_lQe_MMg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="论文精读9：ADSNet"/></a><div class="content"><a class="title" href="/2025/02/17/%E8%AE%BA%E6%96%87%E7%B2%BE%E8%AF%BB9%EF%BC%9AADSNet/" title="论文精读9：ADSNet">论文精读9：ADSNet</a><time datetime="2025-02-17T09:09:52.000Z" title="发表于 2025-02-17 17:09:52">2025-02-17</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/01/27/2024%E5%B9%B4AI%E5%B9%B4%E5%BA%A6%E5%85%B3%E9%94%AE%E8%AF%8D/" title="2024年AI年度关键词"><img src="https://image.uisdc.com/wp-content/uploads/2025/01/banner2025012108482456.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="2024年AI年度关键词"/></a><div class="content"><a class="title" href="/2025/01/27/2024%E5%B9%B4AI%E5%B9%B4%E5%BA%A6%E5%85%B3%E9%94%AE%E8%AF%8D/" title="2024年AI年度关键词">2024年AI年度关键词</a><time datetime="2025-01-27T11:03:16.000Z" title="发表于 2025-01-27 19:03:16">2025-01-27</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url('https://pic4.zhimg.com/v2-3601304d88287b2b8e1736ded4036a43_1440w.jpg?source=172ae18b')"><div id="footer-wrap" style="padding: 5px 5px;"><div class="copyright">&copy;2024 - 2025 By 弘树</div><div id="running-time" style="font-size: 14px;"><script>setInterval(() => {
  let create_time = Math.round((new Date(2024, 1, 23).getTime()) / 1000);
  let timestamp = Math.round((new Date().getTime()) / 1000);
  let second = timestamp - create_time;
  let time = new Array(0, 0, 0, 0, 0);
  if (second >= 365 * 24 * 3600) {
      time[0] = parseInt(second / (365 * 24 * 3600));
      second %= 365 * 24 * 3600;
  }
  if (second >= 24 * 3600) {
      time[1] = parseInt(second / (24 * 3600));
      second %= 24 * 3600;
  }
  if (second >= 3600) {
      time[2] = parseInt(second / 3600);
      second %= 3600;
  }
  if (second >= 60) {
      time[3] = parseInt(second / 60);
      second %= 60;
  }
  if (second > 0) {
      time[4] = second;
  }
  currentTimeHtml = "本站已安全运行 " +
      time[0] + " 年 " +
      (time[1] + 31) + " 天 " +
      time[2] + " 时 " +
      time[3] + " 分 " +
      time[4] + " 秒";
  document.getElementById("running-time").innerHTML = currentTimeHtml;
  }, 1000);</script></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=4.12.0"></script><script src="/js/main.js?v=4.12.0"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.32/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"><script>if (!window.MathJax) {
  window.MathJax = {
    tex: {
      inlineMath: [['$', '$'], ['\\(', '\\)']],
      tags: 'ams'
    },
    chtml: {
      scale: 1.1
    },
    options: {
      renderActions: {
        findScript: [10, doc => {
          for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
            const display = !!node.type.match(/; *mode=display/)
            const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
            const text = document.createTextNode('')
            node.parentNode.replaceChild(text, node)
            math.start = {node: text, delim: '', n: 0}
            math.end = {node: text, delim: '', n: 0}
            doc.math.push(math)
          }
        }, '']
      }
    }
  }
  
  const script = document.createElement('script')
  script.src = 'https://cdn.jsdelivr.net/npm/mathjax@3.2.2/es5/tex-mml-chtml.min.js'
  script.id = 'MathJax-script'
  script.async = true
  document.head.appendChild(script)
} else {
  MathJax.startup.document.state(0)
  MathJax.texReset()
  MathJax.typesetPromise()
}</script><script>(() => {
  const loadUtterances = () => {
    let ele = document.createElement('script')
    ele.id = 'utterances_comment'
    ele.src = 'https://utteranc.es/client.js'
    ele.setAttribute('repo', 'NoyeArk/noyeark.github.io')
    ele.setAttribute('issue-term', 'pathname')
    const nowTheme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'photon-dark' : 'github-light'
    ele.setAttribute('theme', nowTheme)
    ele.crossOrigin = 'anonymous'
    ele.async = true
    document.getElementById('utterances-wrap').appendChild(ele)
  }

  const utterancesTheme = theme => {
    const iframe = document.querySelector('.utterances-frame')
    if (iframe) {
      const theme = theme === 'dark' ? 'photon-dark' : 'github-light'
      const message = {
        type: 'set-theme',
        theme: theme
      };
      iframe.contentWindow.postMessage(message, 'https://utteranc.es');
    }
  }

  btf.addGlobalFn('themeChange', utterancesTheme, 'utterances')

  if ('Utterances' === 'Utterances' || !false) {
    if (false) btf.loadComment(document.getElementById('utterances-wrap'), loadUtterances)
    else loadUtterances()
  } else {
    window.loadOtherComment = loadUtterances
  }
})()</script></div><script src="/js/jquery.js"></script><script src="/js/footer.js"></script><script src="/js/nav.js"></script><script>let tianliGPT_postSelector = '\#post \#article-container';let tianliGPT_key = 'iyiSf8ljbaf';</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js?v=4.12.0"></script></div></div></body></html>